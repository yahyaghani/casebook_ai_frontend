{"ast":null,"code":"/* eslint-disable valid-jsdoc */\n/* eslint-disable security/detect-unsafe-regex */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { measureText } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement, colorNameToHex } from '../../common/utils/helper';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Represents a 3D rendering configuration for the EJ3D rendering engine.\n *\n */\nvar Chart3DRender = /** @class */function () {\n  function Chart3DRender() {\n    this.transform = null; // Chart3DBasicTransform\n  }\n  return Chart3DRender;\n}();\nexport { Chart3DRender };\nvar chart3DRender = new Chart3DRender();\n/**\n * Represents a three-dimensional vector in space.\n */\nvar Vector3D = /** @class */function () {\n  /**\n   * Constructs a new Vector3D instance.\n   *\n   * @constructor\n   * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n   * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n   * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n   */\n  function Vector3D(pointX, vy, vz) {\n    /** The x-coordinate of the vector. */\n    this.x = 0;\n    /** The y-coordinate of the vector. */\n    this.y = 0;\n    /** The z-coordinate of the vector. */\n    this.z = 0;\n    /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n    this.epsilon = 0.00001;\n    this.x = pointX;\n    this.y = vy || 0;\n    this.z = vz || 0;\n  }\n  /**\n   * Checks if a vector is valid (not NaN for any component).\n   *\n   * @param {Chart3DVector} point - The vector to check.\n   * @returns {boolean} - True if the vector is valid, false otherwise.\n   */\n  Vector3D.prototype.isValid = function (point) {\n    return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n  };\n  /**\n   * Creates a new Vector3D instance from provided coordinates.\n   *\n   * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n   * @param {number} vy - The y-coordinate.\n   * @param {number} vz - The z-coordinate.\n   * @returns {Chart3DVector} - The new Vector3D instance.\n   */\n  Vector3D.prototype.vector3D = function (vx, vy, vz) {\n    this.x = vx;\n    this.y = vy;\n    this.z = vz;\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  };\n  /**\n   * Subtracts one vector from another and returns the result.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector to subtract from the first.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DMinus = function (v1, v2) {\n    return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n  };\n  /**\n   * Adds two vectors and returns the result.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector to add to the first.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DPlus = function (v1, v2) {\n    return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n  };\n  /**\n   * Multiplies two vectors using the cross product and returns the result.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DMultiply = function (v1, v2) {\n    var x = v1.y * v2.z - v2.y * v1.z;\n    var y = v1.z * v2.x - v2.z * v1.x;\n    var z = v1.x * v2.y - v2.x * v1.y;\n    return this.vector3D(x, y, z);\n  };\n  /**\n   * Calculates the dot product of two vectors.\n   *\n   * @param {Chart3DVector} v1 - The first vector.\n   * @param {Chart3DVector} v2 - The second vector.\n   * @returns {number} - The dot product.\n   */\n  Vector3D.prototype.vector3DAdd = function (v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  };\n  /**\n   * Multiplies a vector by a scalar value.\n   *\n   * @param {Vector} v1 - The vector to multiply.\n   * @param {number} value - The scalar value.\n   * @returns {Vector} - The resulting vector.\n   */\n  Vector3D.prototype.vector3DStarMultiply = function (v1, value) {\n    var x = v1.x * value;\n    var y = v1.y * value;\n    var z = v1.z * value;\n    return this.vector3D(x, y, z);\n  };\n  /**\n   * Calculates the length of a vector.\n   *\n   * @param {Chart3DVector} vector - The vector to calculate the length of.\n   * @returns {number} - The length of the vector.\n   */\n  Vector3D.prototype.getLength = function (vector) {\n    var sqt = this.vector3DAdd(vector, vector);\n    return Math.sqrt(sqt);\n  };\n  /**\n   * Normalizes the vector to have a length of 1.\n   *\n   * @returns {void}\n   */\n  Vector3D.prototype.normalize = function () {\n    var length = this.getLength(this);\n    this.x /= length;\n    this.y /= length;\n    this.z /= length;\n  };\n  /**\n   * Calculates the normal vector of a triangle defined by three vectors.\n   *\n   * @param {Chart3DVector} v1 - The first vertex of the triangle.\n   * @param {Chart3DVector} v2 - The second vertex of the triangle.\n   * @param {Chart3DVector} v3 - The third vertex of the triangle.\n   * @returns {Chart3DVector} - The normal vector of the triangle.\n   */\n  Vector3D.prototype.getNormal = function (v1, v2, v3) {\n    var vector4 = this.vector3DMinus(v1, v2);\n    var vector5 = this.vector3DMinus(v3, v2);\n    var n = this.vector3DMultiply(vector4, vector5);\n    var length = this.getLength(n);\n    if (length < this.epsilon) {\n      return this.vector3D(0, 0, 0);\n    }\n    return this.vector3D(n.x / length, n.y / length, n.z / length);\n  };\n  return Vector3D;\n}();\nexport { Vector3D };\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar Matrix3D = /** @class */function () {\n  function Matrix3D() {\n    /** The size of the matrix, which is set to 4 by default. */\n    this.matrixSize = 4;\n  }\n  /**\n   * Creates a 3D matrix with the specified size.\n   *\n   * @param {number} size - The size of the matrix.\n   * @returns {number[][]} - The created 3D matrix.\n   */\n  Matrix3D.prototype.matrix3D = function (size) {\n    var matrixData = [];\n    for (var i = 0; i < size; i++) {\n      matrixData[i] = this.createArray(size);\n    }\n    return matrixData;\n  };\n  /**\n   * Checks if a matrix is an affine matrix.\n   *\n   * @param {number[][]} matrixData - The matrix to check.\n   * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n   */\n  Matrix3D.prototype.isAffine = function (matrixData) {\n    return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n  };\n  /**\n   * Creates a new array with zeros.\n   *\n   * @param {number} initialSize - The size of the array.\n   * @returns {number[]} - The created array.\n   */\n  Matrix3D.prototype.createArray = function (initialSize) {\n    var matrixData = [];\n    for (var index = 0; index < initialSize; ++index) {\n      matrixData[index] = 0;\n    }\n    return matrixData;\n  };\n  /**\n   * Gets the identity matrix.\n   *\n   * @returns {number[][]} -The identity matrix.\n   */\n  Matrix3D.prototype.getIdentity = function () {\n    var matrixData = this.matrix3D(this.matrixSize);\n    for (var i = 0; i < this.matrixSize; i++) {\n      matrixData[i][i] = 1.0;\n    }\n    return matrixData;\n  };\n  /**\n   * Gets the interval of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix to get the interval for.\n   * @returns {number[][]} - The interval matrix.\n   */\n  Matrix3D.prototype.getInterval = function (matrix) {\n    var matrixData = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        matrixData[i][j] = this.getMinor(matrix, i, j);\n      }\n    }\n    matrixData = this.transposed(matrixData);\n    matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n    return matrixData;\n  };\n  /**\n   * Multiplies all elements of a matrix by a factor.\n   *\n   * @param {number} factor - The factor to multiply with.\n   * @param {number[][]} matrix - The matrix to multiply.\n   * @returns {number[][]} - The resulting matrix.\n   */\n  Matrix3D.prototype.getMatrixMultiple = function (factor, matrix) {\n    for (var i = 0; i < matrix.length; i++) {\n      for (var j = 0; j < matrix[i].length; j++) {\n        matrix[i][j] = matrix[i][j] * factor;\n      }\n    }\n    return matrix;\n  };\n  /**\n   * Multiplies a matrix by a vector.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {Chart3DVector} point - The vector to multiply with.\n   * @returns {Chart3DVector} - The resulting vector.\n   */\n  Matrix3D.prototype.getMatrixVectorMultiple = function (matrix, point) {\n    var x = matrix[0][0] * point.x + matrix[1][0] * point.y + matrix[2][0] * point.z + matrix[3][0];\n    var y = matrix[0][1] * point.x + matrix[1][1] * point.y + matrix[2][1] * point.z + matrix[3][1];\n    var z = matrix[0][2] * point.x + matrix[1][2] * point.y + matrix[2][2] * point.z + matrix[3][2];\n    if (!this.isAffine(matrix)) {\n      var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n      x *= c;\n      y *= c;\n      z *= c;\n    }\n    return {\n      x: x,\n      y: y,\n      z: z\n    };\n  };\n  /**\n   * Multiplies a matrix by a vector and applies translation.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {Chart3DVector} vector - The vector to multiply with.\n   * @returns {Vector3D} - The resulting vector.\n   */\n  Matrix3D.prototype.getMatrixVectorAnd = function (matrix, vector) {\n    var x = matrix[0][0] * vector.x + matrix[1][0] * vector.y + matrix[2][0] * vector.z;\n    var y = matrix[0][1] * vector.x + matrix[1][1] * vector.y + matrix[2][1] * vector.z;\n    var z = matrix[0][2] * vector.x + matrix[1][2] * vector.y + matrix[2][2] * vector.z;\n    return new Vector3D(x, y, z);\n  };\n  /**\n   * Multiplies two matrices.\n   *\n   * @param {number[][]} matrix1 - The first matrix.\n   * @param {number[][]} matrix2 - The second matrix.\n   * @returns {number[][]} - The resulting matrix.\n   */\n  Matrix3D.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n    var result = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        var value = 0;\n        for (var k = 0; k < this.matrixSize; k++) {\n          value += matrix1[k][j] * matrix2[i][k];\n        }\n        result[i][j] = value;\n      }\n    }\n    return result;\n  };\n  /**\n   * Gets the minor of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {number} columnIndex - The column index.\n   * @param {number} rowIndex - The row index.\n   * @returns {number} - The minor of the matrix.\n   * @private\n   */\n  Matrix3D.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n    return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n  };\n  /**\n   * Gets a submatrix of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @param {number} columnIndex - The column index.\n   * @param {number} rowIndex - The row index.\n   * @returns {number[][]} - The submatrix.\n   */\n  Matrix3D.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n    var count = matrix.length - 1;\n    var subMatrix = this.createArray(count);\n    for (var i = 0; i < count; i++) {\n      var matrixColumn = i >= columnIndex ? i + 1 : i;\n      subMatrix[i] = this.createArray(count);\n      for (var j = 0; j < count; j++) {\n        var matrixRow = j >= rowIndex ? j + 1 : j;\n        subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n      }\n    }\n    return subMatrix;\n  };\n  /**\n   * Gets the determinant of a matrix.\n   *\n   * @param {number[][]} matrix - The matrix.\n   * @returns {number} - The determinant of the matrix.\n   */\n  Matrix3D.prototype.getDeterminant = function (matrix) {\n    var count = matrix.length;\n    var determinant = 0;\n    if (count < 2) {\n      determinant = matrix[0][0];\n    } else {\n      var k = 1;\n      for (var i = 0; i < count; i++) {\n        var submatrix = this.getMatrix(matrix, i, 0);\n        determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n        k = k > 0 ? -1 : 1;\n      }\n    }\n    return determinant;\n  };\n  /**\n   * Transforms a matrix by translation.\n   *\n   * @param {number} x - The x-coordinate of the translation.\n   * @param {number} y - The y-coordinate of the translation.\n   * @param {number} z - The z-coordinate of the translation.\n   * @returns {number[][]} - The transformed matrix.\n   */\n  Matrix3D.prototype.transform = function (x, y, z) {\n    var transformedMatrix = this.getIdentity();\n    transformedMatrix[3][0] = x;\n    transformedMatrix[3][1] = y;\n    transformedMatrix[3][2] = z;\n    return transformedMatrix;\n  };\n  /**\n   * Creates a matrix for rotation around the y-axis.\n   *\n   * @param {number} angle - The angle of rotation.\n   * @returns {number[][]} - The rotation matrix.\n   */\n  Matrix3D.prototype.turn = function (angle) {\n    var rotatedMatrix = this.getIdentity();\n    rotatedMatrix[0][0] = Math.cos(angle);\n    rotatedMatrix[2][0] = -Math.sin(angle);\n    rotatedMatrix[0][2] = Math.sin(angle);\n    rotatedMatrix[2][2] = Math.cos(angle);\n    return rotatedMatrix;\n  };\n  /**\n   * Creates a matrix for rotation around the x-axis.\n   *\n   * @param {number} angle - The angle of rotation.\n   * @returns {number[][]} - The rotation matrix.\n   */\n  Matrix3D.prototype.tilt = function (angle) {\n    var rotatedMatrix = this.getIdentity();\n    rotatedMatrix[1][1] = Math.cos(angle);\n    rotatedMatrix[2][1] = Math.sin(angle);\n    rotatedMatrix[1][2] = -Math.sin(angle);\n    rotatedMatrix[2][2] = Math.cos(angle);\n    return rotatedMatrix;\n  };\n  /**\n   * Transposes a matrix.\n   *\n   * @param {number[][]} matrix3D - The matrix to transpose.\n   * @returns {number[][]} - The transposed matrix.\n   */\n  Matrix3D.prototype.transposed = function (matrix3D) {\n    var transposedMatrix = this.getIdentity();\n    for (var i = 0; i < this.matrixSize; i++) {\n      for (var j = 0; j < this.matrixSize; j++) {\n        transposedMatrix[i][j] = matrix3D[j][i];\n      }\n    }\n    return transposedMatrix;\n  };\n  return Matrix3D;\n}();\nexport { Matrix3D };\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar ChartTransform3D = /** @class */function () {\n  /**\n   * Initializes a new instance of the `ChartTransform3D` class.\n   */\n  function ChartTransform3D() {\n    /** Represents the angle conversion factor from degrees to radians. */\n    this.toRadial = Math.PI / 180;\n    this.vector = new Vector3D(0, 0, 0);\n    this.matrixObj = new Matrix3D();\n  }\n  /**\n   * Creates a 3D transformation based on the specified size.\n   *\n   * @param {Size} size - The size of the viewing area.\n   * @returns {Chart3DBasicTransform} - The 3D transformation.\n   */\n  ChartTransform3D.prototype.transform3D = function (size) {\n    return {\n      viewingArea: size,\n      rotation: 0,\n      tilt: 0,\n      depth: 0,\n      perspectiveAngle: 0,\n      needUpdate: true,\n      centeredMatrix: this.matrixObj.getIdentity(),\n      perspective: this.matrixObj.getIdentity(),\n      resultMatrix: this.matrixObj.getIdentity(),\n      viewMatrix: this.matrixObj.getIdentity()\n    };\n  };\n  /**\n   * Applies the specified 3D transformation to the current state.\n   *\n   * @param {Chart3DBasicTransform} transform - The 3D transformation to apply.\n   * @returns {void} - The 3D transformation.\n   */\n  ChartTransform3D.prototype.transform = function (transform) {\n    this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n    this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n    this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n    this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n    this.updatePerspective(transform.perspectiveAngle, transform);\n    transform.needUpdate = true;\n  };\n  /**\n   * Updates the perspective matrix based on the specified angle.\n   *\n   * @param {number} angle - The perspective angle.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  ChartTransform3D.prototype.updatePerspective = function (angle, transform) {\n    var width = (transform.viewingArea.width + transform.viewingArea.height) * Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0)) + transform.depth * 2 / 2;\n    transform.perspective[0][0] = width;\n    transform.perspective[1][1] = width;\n    transform.perspective[2][3] = 1;\n    transform.perspective[3][3] = width;\n  };\n  /**\n   * Converts degrees to radians.\n   *\n   * @param {number} angle - The angle in degrees.\n   * @returns {number} - The angle in radians.\n   * @private\n   */\n  ChartTransform3D.prototype.degreeToRadianConverter = function (angle) {\n    return angle * Math.PI / 180;\n  };\n  /**\n   * Transforms a 3D vector to screen coordinates based on the current state.\n   *\n   * @param {Chart3DVector} vector3D - The 3D vector to transform.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @param {Matrix3D} chartObj - Optional custom matrix object for transformation.\n   * @returns {Chart3DLocation} - The screen coordinates.\n   */\n  ChartTransform3D.prototype.toScreen = function (vector3D, transform, chartObj) {\n    if (!chartObj) {\n      transform.chartObj = this.matrixObj;\n      vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n    } else {\n      this.matrixObj = chartObj;\n      vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n    }\n    return {\n      x: vector3D.x,\n      y: vector3D.y\n    };\n  };\n  /**\n   * Sets the view matrix in the transformation state.\n   *\n   * @param {number[][]} matrix - The new view matrix.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  ChartTransform3D.prototype.setViewMatrix = function (matrix, transform) {\n    if (transform.viewMatrix === matrix) {\n      return;\n    }\n    transform.viewMatrix = matrix;\n    transform.needUpdate = true;\n  };\n  /**\n   * Calculates the final result matrix based on the current state.\n   *\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @param {Matrix3D} matrixobj - Optional custom matrix object for transformation.\n   * @returns {number[][]} - The final result matrix.\n   */\n  ChartTransform3D.prototype.result = function (transform, matrixobj) {\n    var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n    if (!chartObj) {\n      chartObj = matrixobj;\n    }\n    if (!transform.needUpdate) {\n      return transform.resultMatrix;\n    }\n    var matrixObj = this.matrixObj ? this.matrixObj : matrixobj;\n    transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n    transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n    transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n    transform.needUpdate = false;\n    return transform.resultMatrix;\n  };\n  /**\n   * Sets the center in the transformation state.\n   *\n   * @param {Chart3DVector} center - The new center vector.\n   * @param {Chart3DBasicTransform} transform - The 3D transformation.\n   * @returns {void}\n   */\n  ChartTransform3D.prototype.setCenter = function (center, transform) {\n    transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n    transform.needUpdate = true;\n  };\n  return ChartTransform3D;\n}();\nexport { ChartTransform3D };\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n * @class\n */\nvar Graphics3D = /** @class */function () {\n  function Graphics3D() {\n    /** The vector class. */\n    this.vector = new Vector3D(0, 0, 0);\n  }\n  /**\n   * Adds a visual polygon to the 3D chart and returns its identifier.\n   *\n   * @param {Polygon} polygon - The polygon to add.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {number} - The identifier of the added polygon.\n   */\n  Graphics3D.prototype.addVisual = function (polygon, chart) {\n    if (polygon == null || polygonObj.test()) {\n      return -1;\n    }\n    return bspTreeObj.add(polygon, chart);\n  };\n  /**\n   * Prepares the view for rendering based on specified parameters.\n   *\n   * @param {number} perspectiveAngle - The perspective angle.\n   * @param {number} depth - The depth of the view.\n   * @param {number} rotation - The rotation angle.\n   * @param {number} tilt - The tilt angle.\n   * @param {Size} size - The size of the viewing area.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {void}\n   */\n  Graphics3D.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n    if (arguments.length === 0) {\n      bspTreeObj.build();\n    } else {\n      if (chart3DRender.transform == null) {\n        chart3DRender.transform = chart.transform3D.transform3D(size);\n      } else {\n        chart3DRender.transform.viewingArea = size;\n      }\n      if (!chart3DRender.tree) {\n        chart3DRender.tree = [];\n      }\n      chart3DRender.transform.rotation = rotation;\n      chart3DRender.transform.tilt = tilt;\n      chart3DRender.transform.depth = depth;\n      chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n      chart.transform3D.transform(chart3DRender.transform);\n      chart3DRender.tree[chart.chart3D.id] = bspTreeObj.build();\n    }\n  };\n  /**\n   * Renders the 3D view on the specified panel element.\n   *\n   * @param {Element} panel - The panel element to render the view on.\n   * @param {Chart3D} chart - The 3D chart.\n   * @param {number} rotation - The rotation angle.\n   * @param {number} tilt - The tilt angle.\n   * @param {Size} size - The size of the viewing area.\n   * @param {number} perspectiveAngle - The perspective angle.\n   * @param {number} depth - The depth of the view.\n   * @returns {void}\n   */\n  Graphics3D.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n    var MaxValue = 32767;\n    if (arguments.length === 2) {\n      if (panel == null) {\n        return;\n      }\n      var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n      this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eyeVector, panel, chart);\n    } else {\n      if (panel == null) {\n        return;\n      }\n      if (chart3DRender.transform == null) {\n        chart3DRender.transform = chart.transform3D.transform3D(size);\n      } else {\n        chart3DRender.transform.viewingArea = size;\n      }\n      chart3DRender.transform.rotation = rotation;\n      chart3DRender.transform.tilt = tilt;\n      chart3DRender.transform.depth = depth;\n      chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n      chart.transform3D.transform(chart3DRender.transform);\n      var eye = this.vector.vector3D(0, 0, MaxValue);\n      this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eye, panel, chart);\n    }\n  };\n  /**\n   * Draws a 3D element based on the specified Binary Space Partitioning Node.\n   *\n   * @param {Chart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {void}\n   */\n  Graphics3D.prototype.draw3DElement = function (bspElement, chart) {\n    if (bspElement.plane.element) {\n      if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n        polygonObj.drawText(bspElement.plane, chart);\n      } else if (bspElement.plane.element.tag === 'template') {\n        polygonObj.drawTemplate(bspElement.plane, chart);\n      } else {\n        polygonObj.drawLine(bspElement.plane, chart);\n      }\n    } else {\n      polygonObj.draw(bspElement.plane, chart);\n    }\n  };\n  /**\n   * Draws the 3D nodes starting from the root based on the eye vector.\n   *\n   * @param {Chart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n   * @param {Chart3DVector} eyeVector - The eye vector.\n   * @param {Element} panel - The panel element to render the view on.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {void}\n   */\n  Graphics3D.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n    if (bspElement === null || chart3DRender.transform == null) {\n      return;\n    }\n    while (true) {\n      var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(chart3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n      if (r > bspElement.plane.d) {\n        if (bspElement.front != null) {\n          this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n        }\n        this.draw3DElement(bspElement, chart);\n        if (bspElement.back != null) {\n          bspElement = bspElement.back;\n          continue;\n        }\n      } else {\n        if (bspElement.back != null) {\n          this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n        }\n        this.draw3DElement(bspElement, chart);\n        if (bspElement.front != null) {\n          bspElement = bspElement.front;\n          continue;\n        }\n      }\n      break;\n    }\n  };\n  return Graphics3D;\n}();\nexport { Graphics3D };\n/**\n * Represents a binary tree builder for 3D polygons in a chart.\n *\n */\nvar BinaryTreeBuilder = /** @class */function () {\n  function BinaryTreeBuilder(chart) {\n    /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n    this.epsilon = 0.0005;\n    this.chart = chart;\n  }\n  /**\n   * Adds a polygon to the binary tree and returns its index.\n   *\n   * @param {Polygon} polygon - The polygon to add.\n   * @param {Chart3D} chart - The 3D chart.\n   * @returns {number} - The index of the added polygon.\n   */\n  BinaryTreeBuilder.prototype.add = function (polygon, chart) {\n    this.chart = chart;\n    chart.polygons.push(polygon);\n    return chart.polygons.length - 1;\n  };\n  /**\n   * Gets the next index considering the array length and the current index.\n   *\n   * @param {number} index - The current index.\n   * @param {number} count - The length of the array.\n   * @returns {number} - The next index.\n   */\n  BinaryTreeBuilder.prototype.getNext = function (index, count) {\n    if (index >= count) {\n      return index - count;\n    }\n    if (index < 0) {\n      return index + count;\n    }\n    return index;\n  };\n  /**\n   * Creates a PolyAttributes object based on the vector, index, and result.\n   *\n   * @param {Vector} point - The vector representing the point.\n   * @param {number} index - The index of the point.\n   * @param {string} result - The result classification.\n   * @returns {Chart3DPolyAttributes} - The created PolyAttributes object.\n   */\n  BinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n    return {\n      index: index,\n      result: result,\n      vector: point,\n      isCuttingBackPoint: false,\n      cuttingBackPairIndex: null,\n      alreadyCutBack: false,\n      isCuttingFrontPoint: false,\n      cuttingFrontPairIndex: null,\n      alreadyCutFront: false\n    };\n  };\n  /**\n   * Classifies a point relative to a polygon.\n   *\n   * @param {Chart3DVector} point - The point to classify.\n   * @param {Chart3DPolygon} polygon - The polygon for classification.\n   * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n   */\n  BinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n    var result = 'OnPlane';\n    var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n    if (signedDistance > this.epsilon) {\n      result = 'OnBack';\n    } else if (signedDistance < -this.epsilon) {\n      result = 'OnFront';\n    }\n    return result;\n  };\n  /**\n   * Classifies a polygon relative to another polygon.\n   *\n   * @param {Chart3DPolygon} refPolygon - The reference polygon.\n   * @param {Chart3DPolygon} classPolygon - The polygon to classify.\n   * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n   */\n  BinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n    var result = 'Unknown';\n    var points = classPolygon.points;\n    if (points == null) {\n      return result;\n    }\n    var onBack = 0;\n    var onFront = 0;\n    var onPlane = 0;\n    var normal = refPolygon.normal;\n    var polygonValue = refPolygon.d;\n    for (var i = 0, len = points.length; i < len; i++) {\n      var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n      if (value > this.epsilon) {\n        onBack++;\n      } else if (value < -this.epsilon) {\n        onFront++;\n      } else {\n        onPlane++;\n      }\n      if (onBack > 0 && onFront > 0) {\n        break;\n      }\n    }\n    if (onPlane === points.length) {\n      result = 'OnPlane';\n    } else if (onFront + onPlane === points.length) {\n      result = 'ToRight';\n    } else if (onBack + onPlane === points.length) {\n      result = 'ToLeft';\n    } else {\n      result = 'Unknown';\n    }\n    return result;\n  };\n  /**\n   * Splits a polygon into two parts based on another polygon.\n   *\n   * @param {Chart3DPolygon} splitPolygon - The polygon to split.\n   * @param {Chart3DPolygon} refPolygon - The reference polygon for splitting.\n   * @returns {PolyCollections} - The resulting back and front parts.\n   */\n  BinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n    var backPoint = [];\n    var frontPoint = [];\n    if (splitPolygon.points != null) {\n      var polyPoints = [];\n      var backPartPoints = [];\n      var frontPartPoints = [];\n      var outputs = void 0;\n      var inputs = void 0;\n      var count = splitPolygon.points.length;\n      for (var i = 0; i < count; i++) {\n        var pointB = splitPolygon.points[i];\n        var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n        var sideB = this.classifyPoint(pointB, refPolygon);\n        var sideC = this.classifyPoint(pointC, refPolygon);\n        var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n        polyPoints.push(attributeB);\n        if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n          var vectorValue = vector.vector3DMinus(pointB, pointC);\n          var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n          var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n          var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n          var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n          var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n          polyPoints.push(attributeIntersection);\n          backPartPoints.push(attributeIntersection);\n          frontPartPoints.push(attributeIntersection);\n        } else if (sideB === 'OnPlane') {\n          var pointA = splitPolygon.points[this.getNext(i - 1, count)];\n          var sideA = this.classifyPoint(pointA, refPolygon);\n          if (sideA === sideC) {\n            continue;\n          }\n          if (sideA !== 'OnPlane' && sideC !== 'OnPlane') {\n            backPartPoints.push(attributeB);\n            frontPartPoints.push(attributeB);\n          } else if (sideA === 'OnPlane') {\n            switch (sideC) {\n              case 'OnBack':\n                backPartPoints.push(attributeB);\n                break;\n              case 'OnFront':\n                frontPartPoints.push(attributeB);\n                break;\n            }\n          } else if (sideC === 'OnPlane') {\n            switch (sideA) {\n              case 'OnBack':\n                backPartPoints.push(attributeB);\n                break;\n              case 'OnFront':\n                frontPartPoints.push(attributeB);\n                break;\n            }\n          }\n        }\n      }\n      if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n        for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n          var backAttribute1 = backPartPoints[i];\n          var backAttribute2 = backPartPoints[i + 1];\n          backAttribute1.cuttingBackPoint = true;\n          backAttribute2.cuttingBackPoint = true;\n          backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n          backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n        }\n        for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n          var frontAttribute1 = frontPartPoints[i];\n          var frontAttribute2 = frontPartPoints[i + 1];\n          frontAttribute1.cuttingFrontPoint = true;\n          frontAttribute2.cuttingFrontPoint = true;\n          frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n          frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n        }\n        for (var i = 0; i < backPartPoints.length - 1; i++) {\n          var backAttribute1 = backPartPoints[i];\n          if (backAttribute1.alreadyCutBack) {\n            continue;\n          }\n          outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n          if (outputs.length > 2) {\n            var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n            backPoint.push(__assign({}, polygon1));\n          }\n        }\n        for (var i = 0; i < frontPartPoints.length - 1; i++) {\n          var backAttribute2 = frontPartPoints[i];\n          if (backAttribute2.alreadyCutFront) {\n            continue;\n          }\n          inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n          if (inputs.length > 2) {\n            var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n            frontPoint.push(__assign({}, polygon2));\n          }\n        }\n      }\n    } else {\n      backPoint.push(splitPolygon);\n      frontPoint.push(splitPolygon);\n    }\n    return {\n      backPolygon: backPoint,\n      frontPolygon: frontPoint\n    };\n  };\n  /**\n   * Cuts out the front part of a polygon based on the PolyAttributes.\n   *\n   * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n   * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n   * @returns {Chart3DVector[]} - The resulting points of the front part.\n   */\n  BinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n    var points = [];\n    var currentVertex = initialVertex;\n    while (true) {\n      currentVertex.alreadyCutFront = true;\n      points.push(currentVertex.vector);\n      var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n      if (currentVertex.cuttingFrontPoint) {\n        if (!currentVertexPair.alreadyCutFront) {\n          currentVertex = currentVertexPair;\n        } else {\n          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n          if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n            currentVertex = previousVertexOnBack;\n          } else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n            currentVertex = nextVertexOnBack;\n          } else {\n            return points;\n          }\n        }\n      } else {\n        var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n        var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n        if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n          currentVertex = previousVertexOnBack;\n        } else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n          currentVertex = nextVertexOnBack;\n        } else {\n          return points;\n        }\n      }\n    }\n  };\n  /**\n   * Cuts out the back part of a polygon based on the PolyAttributes.\n   *\n   * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n   * @param {PChart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n   * @returns {Chart3DVector[]} - The resulting points of the back part.\n   */\n  BinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n    var points = [];\n    var currentVertex = initialVertex;\n    while (true) {\n      currentVertex.alreadyCutBack = true;\n      points.push(currentVertex.vector);\n      var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n      if (currentVertex.cuttingBackPoint) {\n        if (!currentVertexPair.alreadyCutBack) {\n          currentVertex = currentVertexPair;\n        } else {\n          var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n          var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n          if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n            currentVertex = previousVertexOnBack;\n          } else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n            currentVertex = nextVertexOnBack;\n          } else {\n            return points;\n          }\n        }\n      } else {\n        var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n        var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n        if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n          currentVertex = previousVertexOnBack;\n        } else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n          currentVertex = nextVertexOnBack;\n        } else {\n          return points;\n        }\n      }\n    }\n  };\n  /**\n   * Builds a Binary Space Partitioning from a list of polygons.\n   *\n   * @param {Chart3DPolygon[]} [points] - The list of polygons to build the tree from.\n   * @returns {Chart3DBspNode} - The root node of the Binary Space Partitioning tree.\n   */\n  BinaryTreeBuilder.prototype.build = function (points) {\n    if (!arguments[0]) {\n      return this.build(this.chart.polygons);\n    } else {\n      var inputPolygons = arguments[0];\n      if (inputPolygons.length < 1) {\n        return null;\n      }\n      var bspNode = {\n        back: null,\n        front: null,\n        plane: null\n      };\n      var plane = inputPolygons[0];\n      bspNode.plane = plane;\n      var polygonsToLeft = [];\n      var polygonsToRight = [];\n      for (var i = 1, len = inputPolygons.length; i < len; i++) {\n        var currentPolygon = inputPolygons[i];\n        if (currentPolygon === plane) {\n          continue;\n        }\n        var classificationResult = this.classifyPolygon(plane, currentPolygon);\n        switch (classificationResult) {\n          case 'OnPlane':\n          case 'ToRight':\n            polygonsToRight.push(currentPolygon);\n            break;\n          case 'ToLeft':\n            polygonsToLeft.push(currentPolygon);\n            break;\n          case 'Unknown':\n            if (currentPolygon.element && (currentPolygon.element.tag === 'line' || currentPolygon.element.tag === 'text')) {\n              polygonsToLeft.push(currentPolygon);\n            } else {\n              var result = this.splitPolygon(currentPolygon, plane);\n              for (var k = 0; k < result.backPolygon.length; k++) {\n                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                polygonsToLeft.push(result.backPolygon[k]);\n              }\n              for (var j = 0; j < result.frontPolygon.length; j++) {\n                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                polygonsToRight.push(result.frontPolygon[j]);\n              }\n            }\n            break;\n        }\n      }\n      if (polygonsToLeft.length > 0) {\n        bspNode.back = this.build(polygonsToLeft);\n      }\n      if (polygonsToRight.length > 0) {\n        bspNode.front = this.build(polygonsToRight);\n      }\n      return bspNode;\n    }\n  };\n  return BinaryTreeBuilder;\n}();\nexport { BinaryTreeBuilder };\n/**\n * The Svg3DRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar Svg3DRenderer = /** @class */function () {\n  function Svg3DRenderer() {}\n  /**\n   * Gets a Chart3DStringBuilder instance for constructing strings.\n   *\n   * @returns {Chart3DStringBuilder} - The StringBuilder instance.\n   */\n  Svg3DRenderer.prototype.getStringBuilder = function () {\n    var data = [];\n    var counter = 0;\n    return {\n      append: function (text) {\n        data[counter++] = text;\n        return this;\n      },\n      remove: function (i, j) {\n        data.splice(i, j || 1);\n        return this;\n      },\n      insert: function (i, text) {\n        data.splice(i, 0, text);\n        return this;\n      },\n      toString: function (text) {\n        return data.join(text || '');\n      }\n    };\n  };\n  /**\n   * Parses a hex color code and returns its Red green Blue values.\n   *\n   * @param {string} hexColorCode - The hex color code.\n   * @returns {Chart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n   */\n  Svg3DRenderer.prototype.hexToValue = function (hexColorCode) {\n    var rgbRegex = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.test(hexColorCode);\n    var result;\n    if (rgbRegex === true) {\n      result = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.exec(hexColorCode);\n      return result ? {\n        red: parseInt(result[1], 10),\n        green: parseInt(result[2], 10),\n        blue: parseInt(result[3], 10),\n        alpha: result[4]\n      } : null;\n    } else {\n      result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n      return result ? {\n        red: parseInt(result[1], 16),\n        green: parseInt(result[2], 16),\n        blue: parseInt(result[3], 16)\n      } : null;\n    }\n  };\n  /**\n   * Converts a Chart3DColorFormat object to its corresponding color string.\n   *\n   * @param {Chart3DColorFormat} color - The color in Chart3DColorFormat.\n   * @returns {string} - The color string representation.\n   */\n  Svg3DRenderer.prototype.hexColor = function (color) {\n    var redValue = color.red;\n    var greenValue = color.green;\n    var blueValue = color.blue;\n    if (color.alpha) {\n      var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n      return returnColor;\n    } else {\n      var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n      hex_1.forEach(function (val, nr) {\n        if (val.length === 1) {\n          hex_1[nr] = '0' + val;\n        }\n      });\n      return '#' + hex_1.join('').toUpperCase();\n    }\n  };\n  /**\n   * Checks if a given color string is in a valid format (hex or rgba).\n   *\n   * @param {string} color - The color string to check.\n   * @returns {boolean} - True if the color string is valid, otherwise false.\n   */\n  Svg3DRenderer.prototype.checkColorFormat = function (color) {\n    var regex = /(rgba?\\((?:\\d{1,3}[,\\)]){3}(?:\\d+\\.\\d+\\))?)|(^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$)/gmi.test(color);\n    return regex;\n  };\n  /**\n   * Draws text on an SVG element.\n   *\n   * @param {any} options - The options for drawing the text.\n   * @param {string | string[]} label - The text label.\n   * @param {FontModel} font - The font settings for the text.\n   * @param {Chart3D} chart - The 3D chart instance.\n   * @returns {Element} - The created SVG text element.\n   */\n  Svg3DRenderer.prototype.drawText = function (options, label, font, chart) {\n    var text = document.getElementById(options.id);\n    if (text === null) {\n      text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    }\n    if (label.length > 1 && typeof label !== 'string') {\n      var dy = 0;\n      for (var i = 0; i < label.length; i++) {\n        var tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n        tspanElement.textContent = label[i];\n        tspanElement.setAttribute('x', String(options.x));\n        tspanElement.setAttribute('dy', String(dy));\n        text.appendChild(tspanElement);\n        dy = measureText(label[i], font, chart.themeStyle.axisLabelFont).height;\n      }\n    } else {\n      text.textContent = label;\n    }\n    text = chart.svgRenderer.setElementAttributes(options, text);\n    return text;\n  };\n  /**\n   * Transforms 3D coordinates to visible 2D coordinates on the chart.\n   *\n   * @param {Chart3DSeries} currentSeries - The current 3D series.\n   * @param {number} x - The x-coordinate in 3D space.\n   * @param {number} y - The y-coordinate in 3D space.\n   * @param {Chart3D} chart - The 3D chart instance.\n   * @returns {Chart3DLocation} - The transformed 2D coordinates.\n   */\n  Svg3DRenderer.prototype.transform3DToVisible = function (currentSeries, x, y, chart) {\n    if (currentSeries.xAxis != null && currentSeries.yAxis != null) {\n      var valueType = currentSeries.xAxis.valueType;\n      var xlogarithmicBase = 10; // Replace with the actual logarithmic base if needed\n      var xIsLogarithmic = valueType === 'Logarithmic';\n      // Apply logarithmic transformation if necessary\n      if (xIsLogarithmic && x > 0) {\n        x = Math.log(x) / Math.log(xlogarithmicBase);\n      }\n      var ylogarithmicBase = currentSeries.yAxis.logBase;\n      var yIsLogarithmic = currentSeries.yAxis.valueType === 'Logarithmic';\n      // Apply logarithmic transformation if necessary\n      if (yIsLogarithmic && y > 0) {\n        y = Math.log(y) / Math.log(ylogarithmicBase);\n      }\n      // Adjust the coordinates based on inverted axes\n      if (chart.requireInvertedAxis) {\n        var left = chart.chartAxisLayoutPanel.seriesClipRect.x;\n        var top_1 = chart.chartAxisLayoutPanel.seriesClipRect.y;\n        var pointX = left + currentSeries.yAxis.rect.width * valueToCoefficients(y, currentSeries.yAxis);\n        var pointY = top_1 + currentSeries.xAxis.rect.height * (1 - valueToCoefficients(x, currentSeries.xAxis));\n        return {\n          x: pointX,\n          y: pointY\n        };\n      } else {\n        var left = currentSeries.xAxis.rect.x;\n        var top_2 = currentSeries.yAxis.rect.y;\n        var newX = left + Math.round(currentSeries.xAxis.rect.width * valueToCoefficients(x, currentSeries.xAxis));\n        var newY = top_2 + Math.round(currentSeries.yAxis.rect.height * (1 - valueToCoefficients(y, currentSeries.yAxis)));\n        return {\n          x: newX,\n          y: newY\n        };\n      }\n    }\n    // Return a default Point if xAxis and yAxis are null\n    return {\n      x: 0,\n      y: 0\n    };\n  };\n  return Svg3DRenderer;\n}();\nexport { Svg3DRenderer };\n/**\n * Represents a 3D polygon in a chart.\n *\n */\nvar Polygon3D = /** @class */function () {\n  function Polygon3D() {\n    /** A small constant used for numerical comparisons. */\n    this.epsilon = 0.00001;\n    /** A small constant used for numerical comparisons. */\n    this.normal = {\n      x: 0,\n      y: 0,\n      z: 0\n    };\n    /** A small constant used for numerical comparisons. */\n    this.vector = new Vector3D(0, 0, 0);\n    /** A small constant used for numerical comparisons. */\n    this.vectorPoints = [];\n    /** A small constant used for numerical comparisons. */\n    this.matrixObj = new Matrix3D();\n    /** A small constant used for numerical comparisons. */\n    this.tabIndex = true;\n  }\n  /**\n   * Creates a 3D polygon.\n   *\n   * @param {Chart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n   * @param {any} [tag] - Additional information or metadata for the polygon.\n   * @param {number} [index] - An index associated with the polygon.\n   * @param {string} [stroke] - The stroke color of the polygon.\n   * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n   * @param {number} [opacity] - The opacity of the polygon.\n   * @param {string} [fill] - The fill color of the polygon.\n   * @param {string} [name] - The name or identifier of the polygon.\n   * @param {Element} [parent] - The parent element to which the polygon belongs.\n   * @param {string} [text] - Additional text associated with the polygon.\n   * @returns {Chart3DPolygon} - Returns the created polygon.\n   */\n  Polygon3D.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n    if (arguments.length === 3) {\n      this.calculateNormal(arguments[0], arguments[1], arguments[2]);\n      return null;\n    } else if (arguments.length === 2) {\n      points = arguments[0];\n      this.calculateNormal(points[0], points[1], points[2]);\n      this.vectorPoints = points;\n      this.calculateNormal(this.vectorPoints);\n      var polygon = arguments[1];\n      polygon.normal = this.normal;\n      polygon.points = points;\n      polygon.vectorPoints = this.vectorPoints;\n      polygon.isSplit = true;\n      polygon.d = this.d;\n      return polygon;\n    } else {\n      this.calculateNormal(points[0], points[1], points[2]);\n      this.vectorPoints = points;\n      this.calculateNormal(this.vectorPoints);\n      var element = {\n        tag: 'path',\n        parent: parent\n      };\n      var polygon = {\n        normal: this.normal,\n        points: points,\n        vectorPoints: this.vectorPoints,\n        index: index,\n        tag: tag,\n        name: name ? name : null,\n        strokeThickness: strokeThickness,\n        opacity: opacity,\n        fill: fill,\n        d: this.d,\n        text: text ? text : '',\n        polygonElement: element\n      };\n      if (arguments.length !== 1) {\n        polygon.polygonElement = element;\n      }\n      return polygon;\n    }\n  };\n  /**\n   * Creates a 3D line.\n   *\n   * @param {Chart3DTickElement} line - The tick elements associated with the line.\n   * @param {number} x1 - The x-coordinate of the starting point.\n   * @param {number} y1 - The y-coordinate of the starting point.\n   * @param {number} x2 - The x-coordinate of the ending point.\n   * @param {number} y2 - The y-coordinate of the ending point.\n   * @param {number} depth - The depth or z-coordinate of the line in 3D space.\n   * @returns {Chart3DPolygon} - Returns the created 3D line as a polygon.\n   */\n  Polygon3D.prototype.createLine = function (line, x1, y1, x2, y2, depth) {\n    var strokeThickness = line.width;\n    var vectorCollection = [];\n    vectorCollection[0] = this.vector.vector3D(x1, y1, depth);\n    vectorCollection[1] = this.vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);\n    vectorCollection[2] = this.vector.vector3D(x2, y2, depth);\n    return this.line3D(line, vectorCollection);\n  };\n  /**\n   *  Creates a 3D line polygon based on the given tick elements and points.\n   *\n   * @param {Chart3DTickElement} element - The tick elements associated with the line.\n   * @param {Chart3DVector[]} points - The array of 3D vector points defining the line in 3D space.\n   * @returns {Chart3DPolygon} - Returns the created 3D line polygon.\n   */\n  Polygon3D.prototype.line3D = function (element, points) {\n    var plane = this.polygon3D(points);\n    plane.element = element;\n    return plane;\n  };\n  /**\n   * Creates a 3D text polygon based on the given label element and points.\n   *\n   * @param {Chart3DLabelElement} element - The label element associated with the text.\n   * @param {Chart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n   * @returns {Polygon} - Returns the created 3D text polygon.\n   */\n  Polygon3D.prototype.text3D = function (element, points) {\n    var plane = this.polygon3D(points);\n    plane.element = element;\n    return plane;\n  };\n  /**\n   * Creates a 3D cylinder based on the given vectors, chart, and styling parameters.\n   *\n   * @param {Chart3DVector} v1 - The start vector of the cylinder.\n   * @param {Chart3DVector} v2 - The end vector of the cylinder.\n   * @param {Chart3D} chart - The 3D chart to which the cylinder belongs.\n   * @param {number} index - The index of the cylinder.\n   * @param {string} type - The type of the cylinder.\n   * @param {string} stroke - The stroke color of the cylinder.\n   * @param {string} fill - The fill color of the cylinder.\n   * @param {number} strokeThickness - The thickness of the stroke.\n   * @param {number} opacity - The opacity of the cylinder.\n   * @param {string} name - The name of the cylinder.\n   * @param {Element} parent - The parent element of the cylinder.\n   * @returns {Polygon[]} - Returns an array of polygons representing the 3D cylinder.\n   */\n  Polygon3D.prototype.createCylinder = function (v1,\n  //top left front vecotr.\n  v2,\n  // bottom right back vector.\n  chart, index, type, stroke, fill, strokeThickness, opacity, name, parent) {\n    var i = 0; //cylinder path count.\n    var offsetX;\n    var offsetY;\n    var offsetZ;\n    var vectorCollection;\n    var pathCount = 24;\n    var theta = 360 / pathCount;\n    var degreeToRadian = Math.PI / 180;\n    var centerZ = (v1.z + v2.z) / 2;\n    var result = [];\n    var outPoints = [];\n    var topVector = [];\n    var bottomVector = [];\n    var radiusB = v2.y - v1.y < v2.z - v1.z ? (v2.y - v1.y) / 2 : (v2.z - v1.z) / 2;\n    var radiusC = v2.x - v1.x < v2.z - v1.z ? (v2.x - v1.x) / 2 : (v2.z - v1.z) / 2;\n    var centerX = (v1.x + v2.x) / 2;\n    var centerY = (v1.y + v2.y) / 2;\n    switch (type) {\n      case 'Bar':\n      case 'StackingBar':\n      case 'StackingBar100':\n        pathCount++;\n        while (pathCount--) {\n          offsetY = centerY + radiusB * Math.cos(i * theta * degreeToRadian);\n          offsetZ = centerZ + radiusB * Math.sin(i * theta * degreeToRadian);\n          outPoints[i] = {\n            Y: offsetY,\n            Z: offsetZ\n          };\n          topVector.push(this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z));\n          bottomVector.push(this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z));\n          if (i > 0) {\n            vectorCollection = [this.vector.vector3D(v1.x, outPoints[i - 1].Y, outPoints[i - 1].Z), this.vector.vector3D(v2.x, outPoints[i - 1].Y, outPoints[i - 1].Z), this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z), this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z)];\n            result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);\n            graphics.addVisual(result[i + 1], chart);\n          }\n          i++;\n        }\n        break;\n      case 'Column':\n      case 'StackingColumn':\n      case 'StackingColumn100':\n        pathCount++;\n        while (pathCount--) {\n          offsetX = centerX + radiusC * Math.cos(i * theta * degreeToRadian);\n          offsetZ = centerZ + radiusC * Math.sin(i * theta * degreeToRadian);\n          outPoints[i] = {\n            Y: offsetX,\n            Z: offsetZ\n          };\n          topVector.push(this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z));\n          bottomVector.push(this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z));\n          if (i > 0) {\n            vectorCollection = [this.vector.vector3D(outPoints[i - 1].Y, v1.y, outPoints[i - 1].Z), this.vector.vector3D(outPoints[i - 1].Y, v2.y, outPoints[i - 1].Z), this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z), this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z)];\n            result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);\n            graphics.addVisual(result[i + 1], chart);\n          }\n          i++;\n        }\n        break;\n      default:\n        break;\n    }\n    result[0] = this.polygon3D(bottomVector, chart, index, stroke, 0, opacity, fill, '-0-' + name, parent);\n    result[1] = this.polygon3D(topVector, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent);\n    graphics.addVisual(result[0], chart);\n    graphics.addVisual(result[1], chart);\n    return result;\n  };\n  /**\n   * Creates a 3D box based on the given vectors, chart, and styling parameters.\n   *\n   * @param {Vector} v1 - The start vector of the box.\n   * @param {Vector} v2 - The end vector of the box.\n   * @param {Chart3D} chart - The 3D chart to which the box belongs.\n   * @param {number} index - The index of the box.\n   * @param {string} stroke - The stroke color of the box.\n   * @param {string} fill - The fill color of the box.\n   * @param {number} strokeThickness - The thickness of the stroke.\n   * @param {number} opacity - The opacity of the box.\n   * @param {boolean} inverse - A boolean indicating whether to inverse the box.\n   * @param {string} name - The name of the box.\n   * @param {Element} parent - The parent element of the box.\n   * @param {string} [text] - Optional text associated with the box.\n   * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D box.\n   *\n   */\n  Polygon3D.prototype.createBox = function (v1,\n  //top left front vecotr.\n  v2,\n  // bottom right back vector.\n  chart, index, stroke, fill, strokeThickness, opacity, inverse, name, parent, text) {\n    var result = [];\n    var point1 = [this.vector.vector3D(v1.x, v1.y, v1.z), this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v2.x, v2.y, v1.z), this.vector.vector3D(v1.x, v2.y, v1.z)];\n    var point2 = [this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v1.x, v2.y, v2.z)];\n    var point3 = [this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v1.x, v1.y, v1.z)];\n    var point4 = [this.vector.vector3D(v1.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v1.z), this.vector.vector3D(v1.x, v2.y, v1.z)];\n    var point5 = [this.vector.vector3D(v1.x, v1.y, v1.z), this.vector.vector3D(v1.x, v1.y, v2.z), this.vector.vector3D(v1.x, v2.y, v2.z), this.vector.vector3D(v1.x, v2.y, v1.z)];\n    var point6 = [this.vector.vector3D(v2.x, v1.y, v1.z), this.vector.vector3D(v2.x, v1.y, v2.z), this.vector.vector3D(v2.x, v2.y, v2.z), this.vector.vector3D(v2.x, v2.y, v1.z)];\n    if (name) {\n      result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + name, parent, text);\n      result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent, text);\n      result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + name, parent, text);\n      result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + name, parent, text);\n      result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + name, parent, text);\n      result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + name, parent, text);\n    } else {\n      result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + index, parent, text);\n      result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + index, parent, text);\n      result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + index, parent, text);\n      result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + index, parent, text);\n      result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + index, parent, text);\n      result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + index, parent, text);\n    }\n    if (inverse) {\n      graphics.addVisual(result[0], chart);\n      graphics.addVisual(result[1], chart);\n      graphics.addVisual(result[2], chart);\n      graphics.addVisual(result[3], chart);\n      graphics.addVisual(result[4], chart);\n      graphics.addVisual(result[5], chart);\n    } else {\n      graphics.addVisual(result[5], chart);\n      graphics.addVisual(result[4], chart);\n      graphics.addVisual(result[0], chart);\n      graphics.addVisual(result[1], chart);\n      graphics.addVisual(result[2], chart);\n      graphics.addVisual(result[3], chart);\n    }\n    return result;\n  };\n  /**\n   * Calculates the normal vector for a 3D polygon based on the provided points.\n   *\n   * @param {...Vector} args - Variable number of vector3d arguments representing points of the polygon.\n   * @returns {void}\n   */\n  Polygon3D.prototype.calculateNormal = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (args.length >= 3) {\n      // Relative information of the points\n      var vector1 = args[0];\n      var vector2 = args[1];\n      var vector3 = args[2];\n      var vector4 = this.vector.vector3DMinus(vector1, vector2);\n      var vector5 = this.vector.vector3DMinus(vector3, vector2);\n      var normal = this.vector.vector3DMultiply(vector4, vector5);\n      var length_1 = this.vector.getLength(normal); // Get length of the vector\n      if (length_1 < this.epsilon) {\n        length_1 = 1;\n      }\n      this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n      this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n      if (args[3]) {\n        args[3].normal = this.normal;\n        args[3].d = this.d;\n      }\n    } else {\n      var Points = args[0];\n      this.calculateNormal(Points[0], Points[1], Points[2], arguments[1]);\n      for (var i = 3; i < Points.length && this.test(); i++) {\n        this.calculateNormal(Points[i], Points[0], Points[i / 2]);\n      }\n    }\n  };\n  /**\n   * Tests whether the calculated normal vector is valid.\n   *\n   * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n   */\n  Polygon3D.prototype.test = function () {\n    return !this.vector.isValid(this.normal);\n  };\n  /**\n   * Transforms the vector points of the specified polygon using the provided matrix.\n   *\n   * @param {number[][]} matrix - The transformation matrix.\n   * @param {Chart3DPolygon} polygon - The polygon to transform.\n   * @returns {void}\n   */\n  Polygon3D.prototype.transform = function (matrix, polygon) {\n    if (polygon.points != null) {\n      for (var i = 0; i < polygon.points.length; i++) {\n        polygon.vectorPoints[i] = polygon.points[i] = matrixObj.getMatrixVectorMultiple(matrix, polygon.points[i]);\n      }\n      this.calculateNormal(polygon.vectorPoints, polygon);\n    }\n  };\n  /**\n   *  Gets the normal vector based on the transformed points using the specified transformation matrix.\n   *\n   * @param {number[][]} transform - The transformation matrix.\n   * @param {Chart3DVector[]} [vectorPoints] - The vector points.\n   * @returns {Chart3DVector} - Returns the normal vector.\n   * @private\n   */\n  Polygon3D.prototype.getNormal = function (transform, vectorPoints) {\n    var normal;\n    if (vectorPoints != null) {\n      normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n      for (var i = 3; i < vectorPoints.length && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n        var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n        var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n        var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n        normal = this.vector.getNormal(v1, v2, v3);\n      }\n    } else {\n      normal = matrixObj.getMatrixVectorAnd(transform);\n      this.vector.normalize();\n    }\n    return normal;\n  };\n  /**\n   * A method for creating text element.\n   *\n   * @param {Vector} position - text position.\n   * @param {Chart3DLabelElement} element - text element.\n   * @param {number} xLength - text element x value.\n   * @param {number} yLength - text element y value.\n   * @returns {Chart3DPolygon} - Returns the polygon.\n   */\n  Polygon3D.prototype.createTextElement = function (position, element, xLength, yLength) {\n    var vectorCollection = [];\n    var x = position.x;\n    var y = position.y;\n    var desiredWidth = element.width;\n    var desiredHeight = element.height;\n    vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n    vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n    vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n    return this.text3D(element, vectorCollection);\n  };\n  /**\n   * Draws a template on the specified 3D chart panel.\n   *\n   * @param {PChart3DPolygon} panel - The 3D polygon representing the panel on which the template will be drawn.\n   * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  Polygon3D.prototype.drawLine = function (panel, chart) {\n    var transform = chart3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var actual3DPosition1 = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    var actual3DPosition2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n    var optionsLine = {\n      'id': panel.element.id,\n      'x1': actual3DPosition1.x,\n      'y1': actual3DPosition1.y,\n      'x2': actual3DPosition2.x,\n      'y2': actual3DPosition2.y,\n      'stroke-dasharray': '',\n      'stroke-width': panel.element.width,\n      'stroke': panel.element.stroke,\n      'opacity': panel.element.opacity\n    };\n    chart.chart3D.appendChild(chart.svgRenderer.drawLine(optionsLine));\n    if (chart.previousID && chart.isTouch) {\n      var previousElement = document.getElementById(chart.previousID);\n      var currentElement = document.getElementById(optionsLine.id);\n      if (previousElement && currentElement) {\n        currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n      }\n    }\n    chart.previousID = optionsLine.id;\n  };\n  /**\n   * Draws text on the specified 3D chart panel.\n   *\n   * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n   * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  Polygon3D.prototype.drawTemplate = function (panel, chart) {\n    var element = panel.element;\n    var transform = chart3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var label = element.label;\n    var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    chart.dataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.visiblePoints[label.pointIndex], element.argsData, label.pointIndex, false, actual3DPosition);\n  };\n  /**\n   * Draws a data label symbol for a specific data point in a three-dimensional series.\n   *\n   * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n   * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n   * @returns {void}\n   */\n  Polygon3D.prototype.drawText = function (panel, chart) {\n    var element = panel.element;\n    var transform = chart3DRender.transform;\n    if (transform == null) {\n      return;\n    }\n    var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n    var x = actual3DPosition.x;\n    var y = actual3DPosition.y;\n    if (element.tag === 'text') {\n      var options = {\n        'id': element.id,\n        'x': x,\n        'y': y,\n        'fill': element.font.color || element.fill,\n        'font-size': element.font.size,\n        'font-family': element.font.fontFamily,\n        'font-style': element.font.fontStyle,\n        'font-weight': element.font.fontWeight,\n        'opacity': element.font.opacity,\n        'text-anchor': element.textAnchor,\n        'cursor': 'default',\n        'transform': element.angle ? 'rotate(' + element.angle + ',' + x + ',' + y + ')' : ''\n      };\n      var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n      if (element.id.indexOf('-axis-title') > -1) {\n        textElement.setAttribute('aria-hidden', 'true');\n      }\n      chart.chart3D.append(textElement);\n    } else {\n      var series = element.series;\n      var labelFormat = series.yAxis && series.yAxis.labelFormat ? series.yAxis.labelFormat : '';\n      var pointText = element.point.text ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);\n      var textOffset = measureText(pointText, series.dataLabel.font, chart.themeStyle.datalabelFont);\n      var margin = series.dataLabel.margin;\n      var width = textOffset.width + margin.left + margin.right;\n      var height = textOffset.height + margin.top + margin.bottom;\n      var location_1 = {\n        x: actual3DPosition.x,\n        y: actual3DPosition.y\n      };\n      var xXalue = location_1.x - margin.left / 2 + margin.right / 2;\n      var yValue = location_1.y - margin.top / 2 - height / margin.top + margin.bottom / 2;\n      var seriesIndex = series.index;\n      this.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, chart);\n    }\n  };\n  /**\n   * Draws a data label symbol for a specific data point in a three-dimensional series.\n   *\n   * @param {number} seriesIndex - The index of the series to which the data point belongs.\n   * @param {Chart3DSeries} series - The three-dimensional series containing the data point.\n   * @param {number} pointIndex - The index of the data point within the series.\n   * @param {number} x - The x-coordinate of the center of the symbol.\n   * @param {number} y - The y-coordinate of the center of the symbol.\n   * @param {number} width - The width of the symbol.\n   * @param {number} height - The height of the symbol.\n   * @param {Chart3D} chart - The three-dimensional chart containing the series.\n   * @returns {void}\n   */\n  Polygon3D.prototype.dataLabelSymbol = function (seriesIndex, series, pointIndex, x, y, width, height, chart) {\n    var path = 'M' + ' ' + (x + -width / 2) + ' ' + (y + -height / 2) + ' ' + 'L' + ' ' + (x + width / 2) + ' ' + (y + -height / 2) + ' ' + 'L' + ' ' + (x + width / 2) + ' ' + (y + height / 2) + ' ' + 'L' + ' ' + (x + -width / 2) + ' ' + (y + height / 2) + ' ' + 'L' + ' ' + (x + -width / 2) + ' ' + (y + -height / 2) + ' z';\n    var Rectoptions = {\n      id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-point-' + pointIndex,\n      fill: series.dataLabel.fill,\n      'stroke-width': series.dataLabel.border.width,\n      'stroke-dasharray': series.dataLabel.border.dashArray,\n      stroke: series.dataLabel.border.color,\n      opacity: series.dataLabel.opacity,\n      visibility: '',\n      d: path\n    };\n    var element = chart.svgRenderer.drawPath(Rectoptions);\n    chart.chart3D.append(element);\n  };\n  /**\n   * Draws a three-dimensional polygon on the specified chart.\n   *\n   * @param {PChart3DPolygon} panel - The polygon to be drawn.\n   * @param {Chart3D} chart - The three-dimensional chart on which the polygon is to be drawn.\n   * @returns {void}\n   */\n  Polygon3D.prototype.draw = function (panel, chart) {\n    if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n      return;\n    }\n    var transform = chart3DRender.transform;\n    var pathDirection = chart.svg3DRenderer.getStringBuilder();\n    var color = panel.fill;\n    var format = chart.svg3DRenderer.checkColorFormat(color);\n    if (!format) {\n      if (color !== 'transparent') {\n        color = colorNameToHex(color);\n      }\n    }\n    var figure = {\n      StartPoint: null\n    };\n    if (transform != null) {\n      figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n      pathDirection.append('M' + ' ' + figure.StartPoint.x + ' ' + figure.StartPoint.y + ' ');\n      for (var i = 0; i < panel.vectorPoints.length; i++) {\n        var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n        pathDirection.append('L' + ' ' + lineSegment.x + ' ' + lineSegment.y + ' ');\n      }\n    }\n    var direction = pathDirection.toString();\n    var name = 'Light';\n    var lightCoefficientZ = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1);\n    var lightCoefficientY = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1);\n    var lightCoefficientX = 2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1);\n    if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n      if (lightCoefficientZ === lightCoefficientX) {\n        name = 'ZLight';\n        color = this.applyZLight(color, chart);\n      } else if (lightCoefficientY === lightCoefficientZ || lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ) {\n        name = 'XLight';\n        color = this.applyXLight(color, chart);\n      } else if (lightCoefficientZ < 0) {\n        name = 'ZLight';\n        color = this.applyZLight(color, chart);\n      } else {\n        name = 'Light';\n      }\n    }\n    var options = {\n      'id': chart.element.id + '-svg' + panel.name,\n      'name': name,\n      'fill': color,\n      'stroke': '',\n      'stroke-width': panel.strokeThickness,\n      'opacity': panel.opacity,\n      'd': direction\n    };\n    var element = chart.svgRenderer.drawPath(options);\n    if (panel.text) {\n      element.setAttribute('aria-label', panel.text);\n      element.setAttribute('role', 'img');\n    }\n    if (panel.name && panel.name.indexOf('-wall-brush') > -1) {\n      element.setAttribute('aria-hidden', 'true');\n    }\n    if (element.id.indexOf('0-region-series-0-point-0') > -1) {\n      if (this.tabIndex) {\n        element.setAttribute('tabindex', '0');\n      } else {\n        var elements = panel.polygonElement.parent.querySelectorAll('[id*=\"0-region-series-0-point-0\"]');\n        if (elements.length > 0) {\n          elements[elements.length - 1].removeAttribute('tabindex');\n        }\n        element.setAttribute('tabindex', '0');\n      }\n      this.tabIndex = false;\n    }\n    appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n    if (chart.previousID && chart.isTouch) {\n      var previousElement = document.getElementById(chart.previousID);\n      var currentElement = document.getElementById(options.id);\n      if (previousElement && currentElement) {\n        currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n      }\n    }\n    chart.previousID = options.id;\n  };\n  /**\n   * Applies a lightening effect to the given color by reducing its red, green and blue components.\n   *\n   * @param {string} color - The input color in hexadecimal format.\n   * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n   * @returns {string} - The lightened color in hexadecimal format.\n   */\n  Polygon3D.prototype.applyXLight = function (color, chart) {\n    var RGB = chart.svg3DRenderer.hexToValue(color);\n    RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n    RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n    RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n    return chart.svg3DRenderer.hexColor(RGB);\n  };\n  /**\n   * Applies a lightening effect to the given color by reducing its red, green and blue components with a focus on the Z-axis.\n   *\n   * @param {string} color - The input color in hexadecimal format.\n   * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n   * @returns {string} - The lightened color in hexadecimal format.\n   */\n  Polygon3D.prototype.applyZLight = function (color, chart) {\n    var RGB = chart.svg3DRenderer.hexToValue(color);\n    RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n    RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n    RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n    return chart.svg3DRenderer.hexColor(RGB);\n  };\n  return Polygon3D;\n}();\nexport { Polygon3D };\nvar vector = new Vector3D(0, 0, 0);\nvar matrixObj = new Matrix3D();\nvar bspTreeObj = new BinaryTreeBuilder();\nvar polygonObj = new Polygon3D();\nvar graphics = new Graphics3D();\n/**\n * Gets the minimum delta value between adjacent data points on a given axis in a three-dimensional chart.\n *\n * @param {Chart3DAxis} axis - The three-dimensional axis for which the delta value is calculated.\n * @param {Chart3DSeries[]} seriesCollection - Collection of three-dimensional series in the chart.\n * @returns {number} - The minimum delta value between adjacent data points on the specified axis.\n */\nexport function getMinPointsDeltaValue(axis, seriesCollection) {\n  var minDelta = Number.MAX_VALUE;\n  var xValues;\n  var minVal;\n  var seriesMin;\n  for (var index = 0; index < seriesCollection.length; index++) {\n    var series = seriesCollection[index];\n    xValues = [];\n    if (series.visible && (axis.name === series.xAxisName || axis.name === 'primaryXAxis' && series.xAxisName === null)) {\n      xValues = series.points.map(function (point) {\n        return point.xValue;\n      });\n      xValues.sort(function (first, second) {\n        return first - second;\n      });\n      if (xValues.length === 1) {\n        seriesMin = axis.valueType === 'DateTime' && series.xMin === series.xMax ? series.xMin - 25920000 : series.xMin;\n        minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ? seriesMin : axis.visibleRange.min);\n        if (minVal !== 0) {\n          minDelta = Math.min(minDelta, minVal);\n        }\n      } else {\n        for (var index_1 = 0; index_1 < xValues.length; index_1++) {\n          var value = xValues[index_1];\n          if (index_1 > 0 && value) {\n            minVal = value - xValues[index_1 - 1];\n            if (minVal !== 0) {\n              minDelta = Math.min(minDelta, minVal);\n            }\n          }\n        }\n      }\n    }\n  }\n  if (minDelta === Number.MAX_VALUE) {\n    minDelta = 1;\n  }\n  return minDelta;\n}\n/**\n * Converts a numeric value to a coefficient based on the given 3D axis.\n *\n * @param {number} value - The numeric value to be converted.\n * @param {Chart3DAxis} axis - The 3D axis for reference.\n * @returns {number} - The coefficient value.\n * @private\n */\nexport function valueToCoefficients(value, axis) {\n  var range = axis.visibleRange;\n  var result = (value - range.min) / range.delta;\n  var isInverse = axis.isAxisInverse;\n  return isInverse ? 1 - result : result;\n}","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","measureText","appendChildElement","colorNameToHex","isNullOrUndefined","Chart3DRender","transform","chart3DRender","Vector3D","pointX","vy","vz","x","y","z","epsilon","isValid","point","isNaN","vector3D","vx","vector3DMinus","v1","v2","vector3DPlus","vector3DMultiply","vector3DAdd","vector3DStarMultiply","value","getLength","vector","sqt","Math","sqrt","normalize","getNormal","v3","vector4","vector5","Matrix3D","matrixSize","matrix3D","size","matrixData","createArray","isAffine","initialSize","index","getIdentity","getInterval","matrix","j","getMinor","transposed","getMatrixMultiple","getDeterminant","factor","getMatrixVectorMultiple","c","getMatrixVectorAnd","getMatrixMultiplication","matrix1","matrix2","result","k","columnIndex","rowIndex","getMatrix","count","subMatrix","matrixColumn","matrixRow","determinant","submatrix","transformedMatrix","turn","angle","rotatedMatrix","cos","sin","tilt","transposedMatrix","ChartTransform3D","toRadial","PI","matrixObj","transform3D","viewingArea","rotation","depth","perspectiveAngle","needUpdate","centeredMatrix","perspective","resultMatrix","viewMatrix","setCenter","width","height","setViewMatrix","updatePerspective","tan","degreeToRadianConverter","abs","toScreen","chartObj","matrixobj","center","Graphics3D","addVisual","polygon","chart","polygonObj","test","bspTreeObj","add","prepareView","build","tree","chart3D","id","view","panel","MaxValue","eyeVector","drawNode3D","eye","draw3DElement","bspElement","plane","element","tag","drawText","drawTemplate","drawLine","draw","r","vectorPoints","d","front","back","BinaryTreeBuilder","polygons","push","getNext","vector3DIndexClassification","isCuttingBackPoint","cuttingBackPairIndex","alreadyCutBack","isCuttingFrontPoint","cuttingFrontPairIndex","alreadyCutFront","classifyPoint","signedDistance","normal","classifyPolygon","refPolygon","classPolygon","points","onBack","onFront","onPlane","polygonValue","len","splitPolygon","backPoint","frontPoint","polyPoints","backPartPoints","frontPartPoints","outputs","inputs","pointB","pointC","sideB","sideC","attributeB","vectorValue","direction","intersectionParameter","intersectionPoint","attributeIntersection","pointA","sideA","backAttribute1","backAttribute2","cuttingBackPoint","alterCuttingBackPairIndex","frontAttribute1","frontAttribute2","cuttingFrontPoint","alterCuttingFrontPairIndex","cutOutBackPolygon","polygon1","polygon3D","cutOutFrontPolygon","polygon2","backPolygon","frontPolygon","initialVertex","currentVertex","currentVertexPair","previousVertexOnBack","nextVertexOnBack","inputPolygons","bspNode","polygonsToLeft","polygonsToRight","currentPolygon","classificationResult","name","Svg3DRenderer","getStringBuilder","data","counter","append","text","remove","splice","insert","toString","join","hexToValue","hexColorCode","rgbRegex","exec","red","parseInt","green","blue","alpha","hexColor","color","redValue","greenValue","blueValue","returnColor","hex_1","forEach","val","nr","toUpperCase","checkColorFormat","regex","options","label","font","document","getElementById","createElementNS","dy","tspanElement","textContent","setAttribute","String","appendChild","themeStyle","axisLabelFont","svgRenderer","setElementAttributes","transform3DToVisible","currentSeries","xAxis","yAxis","valueType","xlogarithmicBase","xIsLogarithmic","log","ylogarithmicBase","logBase","yIsLogarithmic","requireInvertedAxis","left","chartAxisLayoutPanel","seriesClipRect","top_1","rect","valueToCoefficients","pointY","top_2","newX","round","newY","Polygon3D","tabIndex","stroke","strokeThickness","opacity","fill","parent","calculateNormal","isSplit","polygonElement","createLine","line","x1","y1","x2","y2","vectorCollection","line3D","text3D","createCylinder","type","offsetX","offsetY","offsetZ","pathCount","theta","degreeToRadian","centerZ","outPoints","topVector","bottomVector","radiusB","radiusC","centerX","centerY","Y","Z","graphics","createBox","inverse","point1","point2","point3","point4","point5","point6","args","_i","vector1","vector2","vector3","length_1","Points","createTextElement","position","xLength","yLength","desiredWidth","desiredHeight","actual3DPosition1","actual3DPosition2","optionsLine","previousID","isTouch","previousElement","currentElement","parentNode","insertBefore","nextSibling","actual3DPosition","dataLabel3DModule","createDataLabelTemplate","series","dataLabelElement","dataLabel","visiblePoints","pointIndex","argsData","fontFamily","fontStyle","fontWeight","textAnchor","textElement","svg3DRenderer","indexOf","labelFormat","pointText","substring","textOffset","datalabelFont","margin","right","top","bottom","location_1","xXalue","yValue","seriesIndex","dataLabelSymbol","path","Rectoptions","border","dashArray","visibility","drawPath","pathDirection","format","figure","StartPoint","lineSegment","lightCoefficientZ","lightCoefficientY","lightCoefficientX","applyZLight","applyXLight","elements","querySelectorAll","removeAttribute","redraw","RGB","getMinPointsDeltaValue","axis","seriesCollection","minDelta","Number","MAX_VALUE","xValues","minVal","seriesMin","visible","xAxisName","map","xValue","sort","first","second","xMin","xMax","visibleRange","min","index_1","range","delta","isInverse","isAxisInverse"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/@syncfusion/ej2-charts/src/chart3d/utils/chart3dRender.js"],"sourcesContent":["/* eslint-disable valid-jsdoc */\n/* eslint-disable security/detect-unsafe-regex */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { measureText } from '@syncfusion/ej2-svg-base';\nimport { appendChildElement, colorNameToHex } from '../../common/utils/helper';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * Represents a 3D rendering configuration for the EJ3D rendering engine.\n *\n */\nvar Chart3DRender = /** @class */ (function () {\n    function Chart3DRender() {\n        this.transform = null; // Chart3DBasicTransform\n    }\n    return Chart3DRender;\n}());\nexport { Chart3DRender };\nvar chart3DRender = new Chart3DRender();\n/**\n * Represents a three-dimensional vector in space.\n */\nvar Vector3D = /** @class */ (function () {\n    /**\n     * Constructs a new Vector3D instance.\n     *\n     * @constructor\n     * @param {number | { x: number, y: number }} pointX - Either an object with x and y properties or the x-coordinate.\n     * @param {number} [vy] - The y-coordinate (if the first parameter is a number).\n     * @param {number} [vz] - The z-coordinate (if the first parameter is a number).\n     */\n    function Vector3D(pointX, vy, vz) {\n        /** The x-coordinate of the vector. */\n        this.x = 0;\n        /** The y-coordinate of the vector. */\n        this.y = 0;\n        /** The z-coordinate of the vector. */\n        this.z = 0;\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.00001;\n        this.x = pointX;\n        this.y = vy || 0;\n        this.z = vz || 0;\n    }\n    /**\n     * Checks if a vector is valid (not NaN for any component).\n     *\n     * @param {Chart3DVector} point - The vector to check.\n     * @returns {boolean} - True if the vector is valid, false otherwise.\n     */\n    Vector3D.prototype.isValid = function (point) {\n        return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z);\n    };\n    /**\n     * Creates a new Vector3D instance from provided coordinates.\n     *\n     * @param {number | { x: number, y: number }} vx - Either an object with x and y properties or the x-coordinate.\n     * @param {number} vy - The y-coordinate.\n     * @param {number} vz - The z-coordinate.\n     * @returns {Chart3DVector} - The new Vector3D instance.\n     */\n    Vector3D.prototype.vector3D = function (vx, vy, vz) {\n        this.x = vx;\n        this.y = vy;\n        this.z = vz;\n        return { x: this.x, y: this.y, z: this.z };\n    };\n    /**\n     * Subtracts one vector from another and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector to subtract from the first.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DMinus = function (v1, v2) {\n        return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n    };\n    /**\n     * Adds two vectors and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector to add to the first.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DPlus = function (v1, v2) {\n        return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n    };\n    /**\n     * Multiplies two vectors using the cross product and returns the result.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DMultiply = function (v1, v2) {\n        var x = v1.y * v2.z - v2.y * v1.z;\n        var y = v1.z * v2.x - v2.z * v1.x;\n        var z = v1.x * v2.y - v2.x * v1.y;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the dot product of two vectors.\n     *\n     * @param {Chart3DVector} v1 - The first vector.\n     * @param {Chart3DVector} v2 - The second vector.\n     * @returns {number} - The dot product.\n     */\n    Vector3D.prototype.vector3DAdd = function (v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n    };\n    /**\n     * Multiplies a vector by a scalar value.\n     *\n     * @param {Vector} v1 - The vector to multiply.\n     * @param {number} value - The scalar value.\n     * @returns {Vector} - The resulting vector.\n     */\n    Vector3D.prototype.vector3DStarMultiply = function (v1, value) {\n        var x = v1.x * value;\n        var y = v1.y * value;\n        var z = v1.z * value;\n        return this.vector3D(x, y, z);\n    };\n    /**\n     * Calculates the length of a vector.\n     *\n     * @param {Chart3DVector} vector - The vector to calculate the length of.\n     * @returns {number} - The length of the vector.\n     */\n    Vector3D.prototype.getLength = function (vector) {\n        var sqt = this.vector3DAdd(vector, vector);\n        return Math.sqrt(sqt);\n    };\n    /**\n     * Normalizes the vector to have a length of 1.\n     *\n     * @returns {void}\n     */\n    Vector3D.prototype.normalize = function () {\n        var length = this.getLength(this);\n        this.x /= length;\n        this.y /= length;\n        this.z /= length;\n    };\n    /**\n     * Calculates the normal vector of a triangle defined by three vectors.\n     *\n     * @param {Chart3DVector} v1 - The first vertex of the triangle.\n     * @param {Chart3DVector} v2 - The second vertex of the triangle.\n     * @param {Chart3DVector} v3 - The third vertex of the triangle.\n     * @returns {Chart3DVector} - The normal vector of the triangle.\n     */\n    Vector3D.prototype.getNormal = function (v1, v2, v3) {\n        var vector4 = this.vector3DMinus(v1, v2);\n        var vector5 = this.vector3DMinus(v3, v2);\n        var n = this.vector3DMultiply(vector4, vector5);\n        var length = this.getLength(n);\n        if (length < this.epsilon) {\n            return this.vector3D(0, 0, 0);\n        }\n        return this.vector3D(n.x / length, n.y / length, n.z / length);\n    };\n    return Vector3D;\n}());\nexport { Vector3D };\n/**\n * Represents a 3x3 or 4x4 matrix in 3D space and provides various matrix operations.\n *\n */\nvar Matrix3D = /** @class */ (function () {\n    function Matrix3D() {\n        /** The size of the matrix, which is set to 4 by default. */\n        this.matrixSize = 4;\n    }\n    /**\n     * Creates a 3D matrix with the specified size.\n     *\n     * @param {number} size - The size of the matrix.\n     * @returns {number[][]} - The created 3D matrix.\n     */\n    Matrix3D.prototype.matrix3D = function (size) {\n        var matrixData = [];\n        for (var i = 0; i < size; i++) {\n            matrixData[i] = this.createArray(size);\n        }\n        return matrixData;\n    };\n    /**\n     * Checks if a matrix is an affine matrix.\n     *\n     * @param {number[][]} matrixData - The matrix to check.\n     * @returns {boolean} - True if the matrix is an affine matrix, false otherwise.\n     */\n    Matrix3D.prototype.isAffine = function (matrixData) {\n        return matrixData[0][3] === 0 && matrixData[1][3] === 0 && matrixData[2][3] === 0 && matrixData[3][3] === 1;\n    };\n    /**\n     * Creates a new array with zeros.\n     *\n     * @param {number} initialSize - The size of the array.\n     * @returns {number[]} - The created array.\n     */\n    Matrix3D.prototype.createArray = function (initialSize) {\n        var matrixData = [];\n        for (var index = 0; index < initialSize; ++index) {\n            matrixData[index] = 0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the identity matrix.\n     *\n     * @returns {number[][]} -The identity matrix.\n     */\n    Matrix3D.prototype.getIdentity = function () {\n        var matrixData = this.matrix3D(this.matrixSize);\n        for (var i = 0; i < this.matrixSize; i++) {\n            matrixData[i][i] = 1.0;\n        }\n        return matrixData;\n    };\n    /**\n     * Gets the interval of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix to get the interval for.\n     * @returns {number[][]} - The interval matrix.\n     */\n    Matrix3D.prototype.getInterval = function (matrix) {\n        var matrixData = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                matrixData[i][j] = this.getMinor(matrix, i, j);\n            }\n        }\n        matrixData = this.transposed(matrixData);\n        matrixData = this.getMatrixMultiple(1 / this.getDeterminant(matrix), matrixData);\n        return matrixData;\n    };\n    /**\n     * Multiplies all elements of a matrix by a factor.\n     *\n     * @param {number} factor - The factor to multiply with.\n     * @param {number[][]} matrix - The matrix to multiply.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    Matrix3D.prototype.getMatrixMultiple = function (factor, matrix) {\n        for (var i = 0; i < matrix.length; i++) {\n            for (var j = 0; j < matrix[i].length; j++) {\n                matrix[i][j] = matrix[i][j] * factor;\n            }\n        }\n        return matrix;\n    };\n    /**\n     * Multiplies a matrix by a vector.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {Chart3DVector} point - The vector to multiply with.\n     * @returns {Chart3DVector} - The resulting vector.\n     */\n    Matrix3D.prototype.getMatrixVectorMultiple = function (matrix, point) {\n        var x = matrix[0][0] * point.x +\n            matrix[1][0] * point.y +\n            matrix[2][0] * point.z +\n            matrix[3][0];\n        var y = matrix[0][1] * point.x +\n            matrix[1][1] * point.y +\n            matrix[2][1] * point.z +\n            matrix[3][1];\n        var z = matrix[0][2] * point.x +\n            matrix[1][2] * point.y +\n            matrix[2][2] * point.z +\n            matrix[3][2];\n        if (!this.isAffine(matrix)) {\n            var c = 1 / (matrix[0][3] * point.x + matrix[1][3] * point.y + matrix[2][3] * point.z + matrix[3][3]);\n            x *= c;\n            y *= c;\n            z *= c;\n        }\n        return { x: x, y: y, z: z };\n    };\n    /**\n     * Multiplies a matrix by a vector and applies translation.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {Chart3DVector} vector - The vector to multiply with.\n     * @returns {Vector3D} - The resulting vector.\n     */\n    Matrix3D.prototype.getMatrixVectorAnd = function (matrix, vector) {\n        var x = matrix[0][0] * vector.x +\n            matrix[1][0] * vector.y +\n            matrix[2][0] * vector.z;\n        var y = matrix[0][1] * vector.x +\n            matrix[1][1] * vector.y +\n            matrix[2][1] * vector.z;\n        var z = matrix[0][2] * vector.x +\n            matrix[1][2] * vector.y +\n            matrix[2][2] * vector.z;\n        return new Vector3D(x, y, z);\n    };\n    /**\n     * Multiplies two matrices.\n     *\n     * @param {number[][]} matrix1 - The first matrix.\n     * @param {number[][]} matrix2 - The second matrix.\n     * @returns {number[][]} - The resulting matrix.\n     */\n    Matrix3D.prototype.getMatrixMultiplication = function (matrix1, matrix2) {\n        var result = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                var value = 0;\n                for (var k = 0; k < this.matrixSize; k++) {\n                    value += matrix1[k][j] * matrix2[i][k];\n                }\n                result[i][j] = value;\n            }\n        }\n        return result;\n    };\n    /**\n     * Gets the minor of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number} - The minor of the matrix.\n     * @private\n     */\n    Matrix3D.prototype.getMinor = function (matrix, columnIndex, rowIndex) {\n        return ((columnIndex + rowIndex) % 2 === 0 ? 1 : -1) * this.getDeterminant(this.getMatrix(matrix, columnIndex, rowIndex));\n    };\n    /**\n     * Gets a submatrix of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @param {number} columnIndex - The column index.\n     * @param {number} rowIndex - The row index.\n     * @returns {number[][]} - The submatrix.\n     */\n    Matrix3D.prototype.getMatrix = function (matrix, columnIndex, rowIndex) {\n        var count = matrix.length - 1;\n        var subMatrix = this.createArray(count);\n        for (var i = 0; i < count; i++) {\n            var matrixColumn = i >= columnIndex ? i + 1 : i;\n            subMatrix[i] = this.createArray(count);\n            for (var j = 0; j < count; j++) {\n                var matrixRow = j >= rowIndex ? j + 1 : j;\n                subMatrix[i][j] = matrix[matrixColumn][matrixRow];\n            }\n        }\n        return subMatrix;\n    };\n    /**\n     * Gets the determinant of a matrix.\n     *\n     * @param {number[][]} matrix - The matrix.\n     * @returns {number} - The determinant of the matrix.\n     */\n    Matrix3D.prototype.getDeterminant = function (matrix) {\n        var count = matrix.length;\n        var determinant = 0;\n        if (count < 2) {\n            determinant = matrix[0][0];\n        }\n        else {\n            var k = 1;\n            for (var i = 0; i < count; i++) {\n                var submatrix = this.getMatrix(matrix, i, 0);\n                determinant += k * matrix[i][0] * this.getDeterminant(submatrix);\n                k = k > 0 ? -1 : 1;\n            }\n        }\n        return determinant;\n    };\n    /**\n     * Transforms a matrix by translation.\n     *\n     * @param {number} x - The x-coordinate of the translation.\n     * @param {number} y - The y-coordinate of the translation.\n     * @param {number} z - The z-coordinate of the translation.\n     * @returns {number[][]} - The transformed matrix.\n     */\n    Matrix3D.prototype.transform = function (x, y, z) {\n        var transformedMatrix = this.getIdentity();\n        transformedMatrix[3][0] = x;\n        transformedMatrix[3][1] = y;\n        transformedMatrix[3][2] = z;\n        return transformedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the y-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    Matrix3D.prototype.turn = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[0][0] = Math.cos(angle);\n        rotatedMatrix[2][0] = -Math.sin(angle);\n        rotatedMatrix[0][2] = Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Creates a matrix for rotation around the x-axis.\n     *\n     * @param {number} angle - The angle of rotation.\n     * @returns {number[][]} - The rotation matrix.\n     */\n    Matrix3D.prototype.tilt = function (angle) {\n        var rotatedMatrix = this.getIdentity();\n        rotatedMatrix[1][1] = Math.cos(angle);\n        rotatedMatrix[2][1] = Math.sin(angle);\n        rotatedMatrix[1][2] = -Math.sin(angle);\n        rotatedMatrix[2][2] = Math.cos(angle);\n        return rotatedMatrix;\n    };\n    /**\n     * Transposes a matrix.\n     *\n     * @param {number[][]} matrix3D - The matrix to transpose.\n     * @returns {number[][]} - The transposed matrix.\n     */\n    Matrix3D.prototype.transposed = function (matrix3D) {\n        var transposedMatrix = this.getIdentity();\n        for (var i = 0; i < this.matrixSize; i++) {\n            for (var j = 0; j < this.matrixSize; j++) {\n                transposedMatrix[i][j] = matrix3D[j][i];\n            }\n        }\n        return transposedMatrix;\n    };\n    return Matrix3D;\n}());\nexport { Matrix3D };\n/**\n * Represents a 3D chart transformation utility that provides methods for transforming\n * and projecting 3D coordinates onto a 2D screen.\n *\n */\nvar ChartTransform3D = /** @class */ (function () {\n    /**\n     * Initializes a new instance of the `ChartTransform3D` class.\n     */\n    function ChartTransform3D() {\n        /** Represents the angle conversion factor from degrees to radians. */\n        this.toRadial = Math.PI / 180;\n        this.vector = new Vector3D(0, 0, 0);\n        this.matrixObj = new Matrix3D();\n    }\n    /**\n     * Creates a 3D transformation based on the specified size.\n     *\n     * @param {Size} size - The size of the viewing area.\n     * @returns {Chart3DBasicTransform} - The 3D transformation.\n     */\n    ChartTransform3D.prototype.transform3D = function (size) {\n        return {\n            viewingArea: size,\n            rotation: 0,\n            tilt: 0,\n            depth: 0,\n            perspectiveAngle: 0,\n            needUpdate: true,\n            centeredMatrix: this.matrixObj.getIdentity(),\n            perspective: this.matrixObj.getIdentity(),\n            resultMatrix: this.matrixObj.getIdentity(),\n            viewMatrix: this.matrixObj.getIdentity()\n        };\n    };\n    /**\n     * Applies the specified 3D transformation to the current state.\n     *\n     * @param {Chart3DBasicTransform} transform - The 3D transformation to apply.\n     * @returns {void} - The 3D transformation.\n     */\n    ChartTransform3D.prototype.transform = function (transform) {\n        this.setCenter(this.vector.vector3D(transform.viewingArea.width / 2, transform.viewingArea.height / 2, transform.depth / 2), transform);\n        this.setViewMatrix(this.matrixObj.transform(0, 0, transform.depth), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.turn(-this.toRadial * transform.rotation)), transform);\n        this.setViewMatrix(this.matrixObj.getMatrixMultiplication(transform.viewMatrix, this.matrixObj.tilt(-this.toRadial * transform.tilt)), transform);\n        this.updatePerspective(transform.perspectiveAngle, transform);\n        transform.needUpdate = true;\n    };\n    /**\n     * Updates the perspective matrix based on the specified angle.\n     *\n     * @param {number} angle - The perspective angle.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.updatePerspective = function (angle, transform) {\n        var width = (((transform.viewingArea.width + transform.viewingArea.height) *\n            Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (transform.depth * 2) / 2);\n        transform.perspective[0][0] = width;\n        transform.perspective[1][1] = width;\n        transform.perspective[2][3] = 1;\n        transform.perspective[3][3] = width;\n    };\n    /**\n     * Converts degrees to radians.\n     *\n     * @param {number} angle - The angle in degrees.\n     * @returns {number} - The angle in radians.\n     * @private\n     */\n    ChartTransform3D.prototype.degreeToRadianConverter = function (angle) {\n        return angle * Math.PI / 180;\n    };\n    /**\n     * Transforms a 3D vector to screen coordinates based on the current state.\n     *\n     * @param {Chart3DVector} vector3D - The 3D vector to transform.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @param {Matrix3D} chartObj - Optional custom matrix object for transformation.\n     * @returns {Chart3DLocation} - The screen coordinates.\n     */\n    ChartTransform3D.prototype.toScreen = function (vector3D, transform, chartObj) {\n        if (!chartObj) {\n            transform.chartObj = this.matrixObj;\n            vector3D = this.matrixObj.getMatrixVectorMultiple(this.result(transform), vector3D);\n        }\n        else {\n            this.matrixObj = chartObj;\n            vector3D = chartObj.getMatrixVectorMultiple(this.result(transform, chartObj), vector3D);\n        }\n        return { x: vector3D.x, y: vector3D.y };\n    };\n    /**\n     * Sets the view matrix in the transformation state.\n     *\n     * @param {number[][]} matrix - The new view matrix.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.setViewMatrix = function (matrix, transform) {\n        if (transform.viewMatrix === matrix) {\n            return;\n        }\n        transform.viewMatrix = matrix;\n        transform.needUpdate = true;\n    };\n    /**\n     * Calculates the final result matrix based on the current state.\n     *\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @param {Matrix3D} matrixobj - Optional custom matrix object for transformation.\n     * @returns {number[][]} - The final result matrix.\n     */\n    ChartTransform3D.prototype.result = function (transform, matrixobj) {\n        var chartObj = transform.chartObj ? transform.chartObj : this.matrixObj;\n        if (!chartObj) {\n            chartObj = matrixobj;\n        }\n        if (!transform.needUpdate) {\n            return transform.resultMatrix;\n        }\n        var matrixObj = this.matrixObj ? this.matrixObj : matrixobj;\n        transform.resultMatrix = chartObj.getMatrixMultiplication(matrixObj.getInterval(transform.centeredMatrix), transform.perspective);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.viewMatrix);\n        transform.resultMatrix = chartObj.getMatrixMultiplication(transform.resultMatrix, transform.centeredMatrix);\n        transform.needUpdate = false;\n        return transform.resultMatrix;\n    };\n    /**\n     * Sets the center in the transformation state.\n     *\n     * @param {Chart3DVector} center - The new center vector.\n     * @param {Chart3DBasicTransform} transform - The 3D transformation.\n     * @returns {void}\n     */\n    ChartTransform3D.prototype.setCenter = function (center, transform) {\n        transform.centeredMatrix = this.matrixObj.transform(-center.x, -center.y, -center.z);\n        transform.needUpdate = true;\n    };\n    return ChartTransform3D;\n}());\nexport { ChartTransform3D };\n/**\n * Represents a 3D graphics rendering utility for drawing and managing 3D elements in a chart.\n *\n * @class\n */\nvar Graphics3D = /** @class */ (function () {\n    function Graphics3D() {\n        /** The vector class. */\n        this.vector = new Vector3D(0, 0, 0);\n    }\n    /**\n     * Adds a visual polygon to the 3D chart and returns its identifier.\n     *\n     * @param {Polygon} polygon - The polygon to add.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {number} - The identifier of the added polygon.\n     */\n    Graphics3D.prototype.addVisual = function (polygon, chart) {\n        if (polygon == null || polygonObj.test()) {\n            return -1;\n        }\n        return bspTreeObj.add(polygon, chart);\n    };\n    /**\n     * Prepares the view for rendering based on specified parameters.\n     *\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.prepareView = function (perspectiveAngle, depth, rotation, tilt, size, chart) {\n        if (arguments.length === 0) {\n            bspTreeObj.build();\n        }\n        else {\n            if (chart3DRender.transform == null) {\n                chart3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                chart3DRender.transform.viewingArea = size;\n            }\n            if (!chart3DRender.tree) {\n                chart3DRender.tree = [];\n            }\n            chart3DRender.transform.rotation = rotation;\n            chart3DRender.transform.tilt = tilt;\n            chart3DRender.transform.depth = depth;\n            chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(chart3DRender.transform);\n            chart3DRender.tree[chart.chart3D.id] = bspTreeObj.build();\n        }\n    };\n    /**\n     * Renders the 3D view on the specified panel element.\n     *\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {Chart3D} chart - The 3D chart.\n     * @param {number} rotation - The rotation angle.\n     * @param {number} tilt - The tilt angle.\n     * @param {Size} size - The size of the viewing area.\n     * @param {number} perspectiveAngle - The perspective angle.\n     * @param {number} depth - The depth of the view.\n     * @returns {void}\n     */\n    Graphics3D.prototype.view = function (panel, chart, rotation, tilt, size, perspectiveAngle, depth) {\n        var MaxValue = 32767;\n        if (arguments.length === 2) {\n            if (panel == null) {\n                return;\n            }\n            var eyeVector = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eyeVector, panel, chart);\n        }\n        else {\n            if (panel == null) {\n                return;\n            }\n            if (chart3DRender.transform == null) {\n                chart3DRender.transform = chart.transform3D.transform3D(size);\n            }\n            else {\n                chart3DRender.transform.viewingArea = size;\n            }\n            chart3DRender.transform.rotation = rotation;\n            chart3DRender.transform.tilt = tilt;\n            chart3DRender.transform.depth = depth;\n            chart3DRender.transform.perspectiveAngle = perspectiveAngle;\n            chart.transform3D.transform(chart3DRender.transform);\n            var eye = this.vector.vector3D(0, 0, MaxValue);\n            this.drawNode3D(chart3DRender.tree[chart.chart3D.id], eye, panel, chart);\n        }\n    };\n    /**\n     * Draws a 3D element based on the specified Binary Space Partitioning Node.\n     *\n     * @param {Chart3DBspNode} bspElement - The Binary Space Partitioning Node representing the 3D element.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.draw3DElement = function (bspElement, chart) {\n        if (bspElement.plane.element) {\n            if (bspElement.plane.element.tag === 'text' || bspElement.plane.element.tag === 'dataLabel') {\n                polygonObj.drawText(bspElement.plane, chart);\n            }\n            else if (bspElement.plane.element.tag === 'template') {\n                polygonObj.drawTemplate(bspElement.plane, chart);\n            }\n            else {\n                polygonObj.drawLine(bspElement.plane, chart);\n            }\n        }\n        else {\n            polygonObj.draw(bspElement.plane, chart);\n        }\n    };\n    /**\n     * Draws the 3D nodes starting from the root based on the eye vector.\n     *\n     * @param {Chart3DBspNode} bspElement - The root Binary Space Partitioning Node.\n     * @param {Chart3DVector} eyeVector - The eye vector.\n     * @param {Element} panel - The panel element to render the view on.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {void}\n     */\n    Graphics3D.prototype.drawNode3D = function (bspElement, eyeVector, panel, chart) {\n        if (bspElement === null || chart3DRender.transform == null) {\n            return;\n        }\n        while (true) {\n            var r = vector.vector3DAdd(polygonObj.getNormal(chart.transform3D.result(chart3DRender.transform), bspElement.plane.vectorPoints), eyeVector);\n            if (r > bspElement.plane.d) {\n                if (bspElement.front != null) {\n                    this.drawNode3D(bspElement.front, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.back != null) {\n                    bspElement = bspElement.back;\n                    continue;\n                }\n            }\n            else {\n                if (bspElement.back != null) {\n                    this.drawNode3D(bspElement.back, eyeVector, panel, chart);\n                }\n                this.draw3DElement(bspElement, chart);\n                if (bspElement.front != null) {\n                    bspElement = bspElement.front;\n                    continue;\n                }\n            }\n            break;\n        }\n    };\n    return Graphics3D;\n}());\nexport { Graphics3D };\n/**\n * Represents a binary tree builder for 3D polygons in a chart.\n *\n */\nvar BinaryTreeBuilder = /** @class */ (function () {\n    function BinaryTreeBuilder(chart) {\n        /** A small value used for epsilon comparisons to handle floating-point inaccuracies.*/\n        this.epsilon = 0.0005;\n        this.chart = chart;\n    }\n    /**\n     * Adds a polygon to the binary tree and returns its index.\n     *\n     * @param {Polygon} polygon - The polygon to add.\n     * @param {Chart3D} chart - The 3D chart.\n     * @returns {number} - The index of the added polygon.\n     */\n    BinaryTreeBuilder.prototype.add = function (polygon, chart) {\n        this.chart = chart;\n        chart.polygons.push(polygon);\n        return chart.polygons.length - 1;\n    };\n    /**\n     * Gets the next index considering the array length and the current index.\n     *\n     * @param {number} index - The current index.\n     * @param {number} count - The length of the array.\n     * @returns {number} - The next index.\n     */\n    BinaryTreeBuilder.prototype.getNext = function (index, count) {\n        if (index >= count) {\n            return index - count;\n        }\n        if (index < 0) {\n            return index + count;\n        }\n        return index;\n    };\n    /**\n     * Creates a PolyAttributes object based on the vector, index, and result.\n     *\n     * @param {Vector} point - The vector representing the point.\n     * @param {number} index - The index of the point.\n     * @param {string} result - The result classification.\n     * @returns {Chart3DPolyAttributes} - The created PolyAttributes object.\n     */\n    BinaryTreeBuilder.prototype.vector3DIndexClassification = function (point, index, result) {\n        return {\n            index: index,\n            result: result,\n            vector: point,\n            isCuttingBackPoint: false,\n            cuttingBackPairIndex: null,\n            alreadyCutBack: false,\n            isCuttingFrontPoint: false,\n            cuttingFrontPairIndex: null,\n            alreadyCutFront: false\n        };\n    };\n    /**\n     * Classifies a point relative to a polygon.\n     *\n     * @param {Chart3DVector} point - The point to classify.\n     * @param {Chart3DPolygon} polygon - The polygon for classification.\n     * @returns {string} - The classification result ('OnPlane', 'OnBack', 'OnFront').\n     */\n    BinaryTreeBuilder.prototype.classifyPoint = function (point, polygon) {\n        var result = 'OnPlane';\n        var signedDistance = -polygon.d - vector.vector3DAdd(point, polygon.normal);\n        if (signedDistance > this.epsilon) {\n            result = 'OnBack';\n        }\n        else if (signedDistance < -this.epsilon) {\n            result = 'OnFront';\n        }\n        return result;\n    };\n    /**\n     * Classifies a polygon relative to another polygon.\n     *\n     * @param {Chart3DPolygon} refPolygon - The reference polygon.\n     * @param {Chart3DPolygon} classPolygon - The polygon to classify.\n     * @returns {string} - The classification result ('OnPlane', 'ToRight', 'ToLeft', 'Unknown').\n     */\n    BinaryTreeBuilder.prototype.classifyPolygon = function (refPolygon, classPolygon) {\n        var result = 'Unknown';\n        var points = classPolygon.points;\n        if (points == null) {\n            return result;\n        }\n        var onBack = 0;\n        var onFront = 0;\n        var onPlane = 0;\n        var normal = refPolygon.normal;\n        var polygonValue = refPolygon.d;\n        for (var i = 0, len = points.length; i < len; i++) {\n            var value = -polygonValue - vector.vector3DAdd(points[i], normal);\n            if (value > this.epsilon) {\n                onBack++;\n            }\n            else if (value < -this.epsilon) {\n                onFront++;\n            }\n            else {\n                onPlane++;\n            }\n            if (onBack > 0 && onFront > 0) {\n                break;\n            }\n        }\n        if (onPlane === points.length) {\n            result = 'OnPlane';\n        }\n        else if (onFront + onPlane === points.length) {\n            result = 'ToRight';\n        }\n        else if (onBack + onPlane === points.length) {\n            result = 'ToLeft';\n        }\n        else {\n            result = 'Unknown';\n        }\n        return result;\n    };\n    /**\n     * Splits a polygon into two parts based on another polygon.\n     *\n     * @param {Chart3DPolygon} splitPolygon - The polygon to split.\n     * @param {Chart3DPolygon} refPolygon - The reference polygon for splitting.\n     * @returns {PolyCollections} - The resulting back and front parts.\n     */\n    BinaryTreeBuilder.prototype.splitPolygon = function (splitPolygon, refPolygon) {\n        var backPoint = [];\n        var frontPoint = [];\n        if (splitPolygon.points != null) {\n            var polyPoints = [];\n            var backPartPoints = [];\n            var frontPartPoints = [];\n            var outputs = void 0;\n            var inputs = void 0;\n            var count = splitPolygon.points.length;\n            for (var i = 0; i < count; i++) {\n                var pointB = splitPolygon.points[i];\n                var pointC = splitPolygon.points[this.getNext(i + 1, count)];\n                var sideB = this.classifyPoint(pointB, refPolygon);\n                var sideC = this.classifyPoint(pointC, refPolygon);\n                var attributeB = this.vector3DIndexClassification(pointB, polyPoints.length, sideB);\n                polyPoints.push(attributeB);\n                if (sideB !== sideC && sideB !== 'OnPlane' && sideC !== 'OnPlane') {\n                    var vectorValue = vector.vector3DMinus(pointB, pointC);\n                    var direction = vector.vector3DMinus(vector.vector3DStarMultiply(refPolygon.normal, -refPolygon.d), pointC);\n                    var signedDistance = vector.vector3DAdd(direction, refPolygon.normal);\n                    var intersectionParameter = signedDistance / vector.vector3DAdd(refPolygon.normal, vectorValue);\n                    var intersectionPoint = vector.vector3DPlus(pointC, vector.vector3DStarMultiply(vectorValue, intersectionParameter));\n                    var attributeIntersection = this.vector3DIndexClassification(intersectionPoint, polyPoints.length, 'OnPlane');\n                    polyPoints.push(attributeIntersection);\n                    backPartPoints.push(attributeIntersection);\n                    frontPartPoints.push(attributeIntersection);\n                }\n                else if (sideB === 'OnPlane') {\n                    var pointA = splitPolygon.points[this.getNext(i - 1, count)];\n                    var sideA = this.classifyPoint(pointA, refPolygon);\n                    if (sideA === sideC) {\n                        continue;\n                    }\n                    if (sideA !== 'OnPlane' && sideC !== 'OnPlane') {\n                        backPartPoints.push(attributeB);\n                        frontPartPoints.push(attributeB);\n                    }\n                    else if (sideA === 'OnPlane') {\n                        switch (sideC) {\n                            case 'OnBack':\n                                backPartPoints.push(attributeB);\n                                break;\n                            case 'OnFront':\n                                frontPartPoints.push(attributeB);\n                                break;\n                        }\n                    }\n                    else if (sideC === 'OnPlane') {\n                        switch (sideA) {\n                            case 'OnBack':\n                                backPartPoints.push(attributeB);\n                                break;\n                            case 'OnFront':\n                                frontPartPoints.push(attributeB);\n                                break;\n                        }\n                    }\n                }\n            }\n            if (frontPartPoints.length !== 0 || backPartPoints.length !== 0) {\n                for (var i = 0; i < backPartPoints.length - 1; i += 2) {\n                    var backAttribute1 = backPartPoints[i];\n                    var backAttribute2 = backPartPoints[i + 1];\n                    backAttribute1.cuttingBackPoint = true;\n                    backAttribute2.cuttingBackPoint = true;\n                    backAttribute1.alterCuttingBackPairIndex = backAttribute2.index;\n                    backAttribute2.alterCuttingBackPairIndex = backAttribute1.index;\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i += 2) {\n                    var frontAttribute1 = frontPartPoints[i];\n                    var frontAttribute2 = frontPartPoints[i + 1];\n                    frontAttribute1.cuttingFrontPoint = true;\n                    frontAttribute2.cuttingFrontPoint = true;\n                    frontAttribute1.alterCuttingFrontPairIndex = frontAttribute2.index;\n                    frontAttribute2.alterCuttingFrontPairIndex = frontAttribute1.index;\n                }\n                for (var i = 0; i < backPartPoints.length - 1; i++) {\n                    var backAttribute1 = backPartPoints[i];\n                    if (backAttribute1.alreadyCutBack) {\n                        continue;\n                    }\n                    outputs = this.cutOutBackPolygon(polyPoints, backAttribute1);\n                    if (outputs.length > 2) {\n                        var polygon1 = polygonObj.polygon3D(outputs, splitPolygon);\n                        backPoint.push(__assign({}, polygon1));\n                    }\n                }\n                for (var i = 0; i < frontPartPoints.length - 1; i++) {\n                    var backAttribute2 = frontPartPoints[i];\n                    if (backAttribute2.alreadyCutFront) {\n                        continue;\n                    }\n                    inputs = this.cutOutFrontPolygon(polyPoints, backAttribute2);\n                    if (inputs.length > 2) {\n                        var polygon2 = polygonObj.polygon3D(inputs, splitPolygon);\n                        frontPoint.push(__assign({}, polygon2));\n                    }\n                }\n            }\n        }\n        else {\n            backPoint.push(splitPolygon);\n            frontPoint.push(splitPolygon);\n        }\n        return { backPolygon: backPoint, frontPolygon: frontPoint };\n    };\n    /**\n     * Cuts out the front part of a polygon based on the PolyAttributes.\n     *\n     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {Chart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {Chart3DVector[]} - The resulting points of the front part.\n     */\n    BinaryTreeBuilder.prototype.cutOutFrontPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        while (true) {\n            currentVertex.alreadyCutFront = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingFrontPairIndex];\n            if (currentVertex.cuttingFrontPoint) {\n                if (!currentVertexPair.alreadyCutFront) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnFront' && !previousVertexOnBack.alreadyCutFront) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnFront' && !nextVertexOnBack.alreadyCutFront) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnBack' && !previousVertexOnBack.alreadyCutFront) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnBack' && !nextVertexOnBack.alreadyCutFront) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n    };\n    /**\n     * Cuts out the back part of a polygon based on the PolyAttributes.\n     *\n     * @param {Chart3DPolyAttributes[]} polyPoints - The PolyAttributes array of the polygon.\n     * @param {PChart3DPolyAttributes} initialVertex - The PolyAttributes representing the cutting point.\n     * @returns {Chart3DVector[]} - The resulting points of the back part.\n     */\n    BinaryTreeBuilder.prototype.cutOutBackPolygon = function (polyPoints, initialVertex) {\n        var points = [];\n        var currentVertex = initialVertex;\n        while (true) {\n            currentVertex.alreadyCutBack = true;\n            points.push(currentVertex.vector);\n            var currentVertexPair = polyPoints[currentVertex.alterCuttingBackPairIndex];\n            if (currentVertex.cuttingBackPoint) {\n                if (!currentVertexPair.alreadyCutBack) {\n                    currentVertex = currentVertexPair;\n                }\n                else {\n                    var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                    var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                    if (previousVertexOnBack.result === 'OnBack' && !previousVertexOnBack.alreadyCutBack) {\n                        currentVertex = previousVertexOnBack;\n                    }\n                    else if (nextVertexOnBack.result === 'OnBack' && !nextVertexOnBack.alreadyCutBack) {\n                        currentVertex = nextVertexOnBack;\n                    }\n                    else {\n                        return points;\n                    }\n                }\n            }\n            else {\n                var previousVertexOnBack = polyPoints[this.getNext(currentVertex.index - 1, polyPoints.length)];\n                var nextVertexOnBack = polyPoints[this.getNext(currentVertex.index + 1, polyPoints.length)];\n                if (previousVertexOnBack.result !== 'OnFront' && !previousVertexOnBack.alreadyCutBack) {\n                    currentVertex = previousVertexOnBack;\n                }\n                else if (nextVertexOnBack.result !== 'OnFront' && !nextVertexOnBack.alreadyCutBack) {\n                    currentVertex = nextVertexOnBack;\n                }\n                else {\n                    return points;\n                }\n            }\n        }\n    };\n    /**\n     * Builds a Binary Space Partitioning from a list of polygons.\n     *\n     * @param {Chart3DPolygon[]} [points] - The list of polygons to build the tree from.\n     * @returns {Chart3DBspNode} - The root node of the Binary Space Partitioning tree.\n     */\n    BinaryTreeBuilder.prototype.build = function (points) {\n        if (!arguments[0]) {\n            return this.build(this.chart.polygons);\n        }\n        else {\n            var inputPolygons = arguments[0];\n            if (inputPolygons.length < 1) {\n                return null;\n            }\n            var bspNode = { back: null, front: null, plane: null };\n            var plane = inputPolygons[0];\n            bspNode.plane = plane;\n            var polygonsToLeft = [];\n            var polygonsToRight = [];\n            for (var i = 1, len = inputPolygons.length; i < len; i++) {\n                var currentPolygon = inputPolygons[i];\n                if (currentPolygon === plane) {\n                    continue;\n                }\n                var classificationResult = this.classifyPolygon(plane, currentPolygon);\n                switch (classificationResult) {\n                    case 'OnPlane':\n                    case 'ToRight':\n                        polygonsToRight.push(currentPolygon);\n                        break;\n                    case 'ToLeft':\n                        polygonsToLeft.push(currentPolygon);\n                        break;\n                    case 'Unknown':\n                        if (currentPolygon.element && (currentPolygon.element.tag === 'line' || currentPolygon.element.tag === 'text')) {\n                            polygonsToLeft.push(currentPolygon);\n                        }\n                        else {\n                            var result = this.splitPolygon(currentPolygon, plane);\n                            for (var k = 0; k < result.backPolygon.length; k++) {\n                                result.backPolygon[k].name = result.backPolygon[k].name + '-back';\n                                polygonsToLeft.push(result.backPolygon[k]);\n                            }\n                            for (var j = 0; j < result.frontPolygon.length; j++) {\n                                result.frontPolygon[j].name = result.frontPolygon[j].name + '-front';\n                                polygonsToRight.push(result.frontPolygon[j]);\n                            }\n                        }\n                        break;\n                }\n            }\n            if (polygonsToLeft.length > 0) {\n                bspNode.back = this.build(polygonsToLeft);\n            }\n            if (polygonsToRight.length > 0) {\n                bspNode.front = this.build(polygonsToRight);\n            }\n            return bspNode;\n        }\n    };\n    return BinaryTreeBuilder;\n}());\nexport { BinaryTreeBuilder };\n/**\n * The Svg3DRenderer class provides methods for rendering SVG graphics in a 3D context.\n */\nvar Svg3DRenderer = /** @class */ (function () {\n    function Svg3DRenderer() {\n    }\n    /**\n     * Gets a Chart3DStringBuilder instance for constructing strings.\n     *\n     * @returns {Chart3DStringBuilder} - The StringBuilder instance.\n     */\n    Svg3DRenderer.prototype.getStringBuilder = function () {\n        var data = [];\n        var counter = 0;\n        return {\n            append: function (text) {\n                data[counter++] = text;\n                return this;\n            },\n            remove: function (i, j) {\n                data.splice(i, j || 1);\n                return this;\n            },\n            insert: function (i, text) {\n                data.splice(i, 0, text);\n                return this;\n            },\n            toString: function (text) {\n                return data.join(text || '');\n            }\n        };\n    };\n    /**\n     * Parses a hex color code and returns its Red green Blue values.\n     *\n     * @param {string} hexColorCode - The hex color code.\n     * @returns {Chart3DColorFormat | null} - The parsed color format (Red green Blue) or null if parsing fails.\n     */\n    Svg3DRenderer.prototype.hexToValue = function (hexColorCode) {\n        var rgbRegex = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.test(hexColorCode);\n        var result;\n        if (rgbRegex === true) {\n            result = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/.exec(hexColorCode);\n            return result\n                ? {\n                    red: parseInt(result[1], 10),\n                    green: parseInt(result[2], 10),\n                    blue: parseInt(result[3], 10),\n                    alpha: result[4]\n                }\n                : null;\n        }\n        else {\n            result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hexColorCode);\n            return result\n                ? {\n                    red: parseInt(result[1], 16),\n                    green: parseInt(result[2], 16),\n                    blue: parseInt(result[3], 16)\n                }\n                : null;\n        }\n    };\n    /**\n     * Converts a Chart3DColorFormat object to its corresponding color string.\n     *\n     * @param {Chart3DColorFormat} color - The color in Chart3DColorFormat.\n     * @returns {string} - The color string representation.\n     */\n    Svg3DRenderer.prototype.hexColor = function (color) {\n        var redValue = color.red;\n        var greenValue = color.green;\n        var blueValue = color.blue;\n        if (color.alpha) {\n            var returnColor = \"rgba(\" + redValue.toString() + \",\" + greenValue.toString() + \",\" + blueValue.toString() + \",\" + color.alpha + \")\";\n            return returnColor;\n        }\n        else {\n            var hex_1 = [redValue.toString(16), greenValue.toString(16), blueValue.toString(16)];\n            hex_1.forEach(function (val, nr) {\n                if (val.length === 1) {\n                    hex_1[nr] = '0' + val;\n                }\n            });\n            return '#' + hex_1.join('').toUpperCase();\n        }\n    };\n    /**\n     * Checks if a given color string is in a valid format (hex or rgba).\n     *\n     * @param {string} color - The color string to check.\n     * @returns {boolean} - True if the color string is valid, otherwise false.\n     */\n    Svg3DRenderer.prototype.checkColorFormat = function (color) {\n        var regex = /(rgba?\\((?:\\d{1,3}[,\\)]){3}(?:\\d+\\.\\d+\\))?)|(^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$)/gmi.test(color);\n        return regex;\n    };\n    /**\n     * Draws text on an SVG element.\n     *\n     * @param {any} options - The options for drawing the text.\n     * @param {string | string[]} label - The text label.\n     * @param {FontModel} font - The font settings for the text.\n     * @param {Chart3D} chart - The 3D chart instance.\n     * @returns {Element} - The created SVG text element.\n     */\n    Svg3DRenderer.prototype.drawText = function (options, label, font, chart) {\n        var text = document.getElementById(options.id);\n        if (text === null) {\n            text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        }\n        if (label.length > 1 && typeof label !== 'string') {\n            var dy = 0;\n            for (var i = 0; i < label.length; i++) {\n                var tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n                tspanElement.textContent = label[i];\n                tspanElement.setAttribute('x', String(options.x));\n                tspanElement.setAttribute('dy', String(dy));\n                text.appendChild(tspanElement);\n                dy = measureText(label[i], font, chart.themeStyle.axisLabelFont).height;\n            }\n        }\n        else {\n            text.textContent = label;\n        }\n        text = chart.svgRenderer.setElementAttributes(options, text);\n        return text;\n    };\n    /**\n     * Transforms 3D coordinates to visible 2D coordinates on the chart.\n     *\n     * @param {Chart3DSeries} currentSeries - The current 3D series.\n     * @param {number} x - The x-coordinate in 3D space.\n     * @param {number} y - The y-coordinate in 3D space.\n     * @param {Chart3D} chart - The 3D chart instance.\n     * @returns {Chart3DLocation} - The transformed 2D coordinates.\n     */\n    Svg3DRenderer.prototype.transform3DToVisible = function (currentSeries, x, y, chart) {\n        if (currentSeries.xAxis != null && currentSeries.yAxis != null) {\n            var valueType = currentSeries.xAxis.valueType;\n            var xlogarithmicBase = 10; // Replace with the actual logarithmic base if needed\n            var xIsLogarithmic = valueType === 'Logarithmic';\n            // Apply logarithmic transformation if necessary\n            if (xIsLogarithmic && x > 0) {\n                x = Math.log(x) / Math.log(xlogarithmicBase);\n            }\n            var ylogarithmicBase = currentSeries.yAxis.logBase;\n            var yIsLogarithmic = currentSeries.yAxis.valueType === 'Logarithmic';\n            // Apply logarithmic transformation if necessary\n            if (yIsLogarithmic && y > 0) {\n                y = Math.log(y) / Math.log(ylogarithmicBase);\n            }\n            // Adjust the coordinates based on inverted axes\n            if (chart.requireInvertedAxis) {\n                var left = chart.chartAxisLayoutPanel.seriesClipRect.x;\n                var top_1 = chart.chartAxisLayoutPanel.seriesClipRect.y;\n                var pointX = left + currentSeries.yAxis.rect.width * valueToCoefficients(y, currentSeries.yAxis);\n                var pointY = top_1 + currentSeries.xAxis.rect.height * (1 - valueToCoefficients(x, currentSeries.xAxis));\n                return { x: pointX, y: pointY };\n            }\n            else {\n                var left = currentSeries.xAxis.rect.x;\n                var top_2 = currentSeries.yAxis.rect.y;\n                var newX = left + Math.round(currentSeries.xAxis.rect.width * valueToCoefficients(x, currentSeries.xAxis));\n                var newY = top_2 + Math.round(currentSeries.yAxis.rect.height * (1 - valueToCoefficients(y, currentSeries.yAxis)));\n                return { x: newX, y: newY };\n            }\n        }\n        // Return a default Point if xAxis and yAxis are null\n        return { x: 0, y: 0 };\n    };\n    return Svg3DRenderer;\n}());\nexport { Svg3DRenderer };\n/**\n * Represents a 3D polygon in a chart.\n *\n */\nvar Polygon3D = /** @class */ (function () {\n    function Polygon3D() {\n        /** A small constant used for numerical comparisons. */\n        this.epsilon = 0.00001;\n        /** A small constant used for numerical comparisons. */\n        this.normal = { x: 0, y: 0, z: 0 };\n        /** A small constant used for numerical comparisons. */\n        this.vector = new Vector3D(0, 0, 0);\n        /** A small constant used for numerical comparisons. */\n        this.vectorPoints = [];\n        /** A small constant used for numerical comparisons. */\n        this.matrixObj = new Matrix3D();\n        /** A small constant used for numerical comparisons. */\n        this.tabIndex = true;\n    }\n    /**\n     * Creates a 3D polygon.\n     *\n     * @param {Chart3DVector[]} [points] - An array of 3D vectors representing points on the polygon.\n     * @param {any} [tag] - Additional information or metadata for the polygon.\n     * @param {number} [index] - An index associated with the polygon.\n     * @param {string} [stroke] - The stroke color of the polygon.\n     * @param {number} [strokeThickness] - The thickness of the polygon's stroke.\n     * @param {number} [opacity] - The opacity of the polygon.\n     * @param {string} [fill] - The fill color of the polygon.\n     * @param {string} [name] - The name or identifier of the polygon.\n     * @param {Element} [parent] - The parent element to which the polygon belongs.\n     * @param {string} [text] - Additional text associated with the polygon.\n     * @returns {Chart3DPolygon} - Returns the created polygon.\n     */\n    Polygon3D.prototype.polygon3D = function (points, tag, index, stroke, strokeThickness, opacity, fill, name, parent, text) {\n        if (arguments.length === 3) {\n            this.calculateNormal(arguments[0], arguments[1], arguments[2]);\n            return null;\n        }\n        else if (arguments.length === 2) {\n            points = arguments[0];\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var polygon = arguments[1];\n            polygon.normal = this.normal;\n            polygon.points = points;\n            polygon.vectorPoints = this.vectorPoints;\n            polygon.isSplit = true;\n            polygon.d = this.d;\n            return polygon;\n        }\n        else {\n            this.calculateNormal(points[0], points[1], points[2]);\n            this.vectorPoints = points;\n            this.calculateNormal(this.vectorPoints);\n            var element = { tag: 'path', parent: parent };\n            var polygon = {\n                normal: this.normal,\n                points: points,\n                vectorPoints: this.vectorPoints,\n                index: index,\n                tag: tag,\n                name: name ? name : null,\n                strokeThickness: strokeThickness,\n                opacity: opacity,\n                fill: fill,\n                d: this.d,\n                text: text ? text : '',\n                polygonElement: element\n            };\n            if (arguments.length !== 1) {\n                polygon.polygonElement = element;\n            }\n            return polygon;\n        }\n    };\n    /**\n     * Creates a 3D line.\n     *\n     * @param {Chart3DTickElement} line - The tick elements associated with the line.\n     * @param {number} x1 - The x-coordinate of the starting point.\n     * @param {number} y1 - The y-coordinate of the starting point.\n     * @param {number} x2 - The x-coordinate of the ending point.\n     * @param {number} y2 - The y-coordinate of the ending point.\n     * @param {number} depth - The depth or z-coordinate of the line in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D line as a polygon.\n     */\n    Polygon3D.prototype.createLine = function (line, x1, y1, x2, y2, depth) {\n        var strokeThickness = line.width;\n        var vectorCollection = [];\n        vectorCollection[0] = this.vector.vector3D(x1, y1, depth);\n        vectorCollection[1] = this.vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);\n        vectorCollection[2] = this.vector.vector3D(x2, y2, depth);\n        return this.line3D(line, vectorCollection);\n    };\n    /**\n     *  Creates a 3D line polygon based on the given tick elements and points.\n     *\n     * @param {Chart3DTickElement} element - The tick elements associated with the line.\n     * @param {Chart3DVector[]} points - The array of 3D vector points defining the line in 3D space.\n     * @returns {Chart3DPolygon} - Returns the created 3D line polygon.\n     */\n    Polygon3D.prototype.line3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D text polygon based on the given label element and points.\n     *\n     * @param {Chart3DLabelElement} element - The label element associated with the text.\n     * @param {Chart3DVector[]} points - The array of 3D vector points defining the position of the text in 3D space.\n     * @returns {Polygon} - Returns the created 3D text polygon.\n     */\n    Polygon3D.prototype.text3D = function (element, points) {\n        var plane = this.polygon3D(points);\n        plane.element = element;\n        return plane;\n    };\n    /**\n     * Creates a 3D cylinder based on the given vectors, chart, and styling parameters.\n     *\n     * @param {Chart3DVector} v1 - The start vector of the cylinder.\n     * @param {Chart3DVector} v2 - The end vector of the cylinder.\n     * @param {Chart3D} chart - The 3D chart to which the cylinder belongs.\n     * @param {number} index - The index of the cylinder.\n     * @param {string} type - The type of the cylinder.\n     * @param {string} stroke - The stroke color of the cylinder.\n     * @param {string} fill - The fill color of the cylinder.\n     * @param {number} strokeThickness - The thickness of the stroke.\n     * @param {number} opacity - The opacity of the cylinder.\n     * @param {string} name - The name of the cylinder.\n     * @param {Element} parent - The parent element of the cylinder.\n     * @returns {Polygon[]} - Returns an array of polygons representing the 3D cylinder.\n     */\n    Polygon3D.prototype.createCylinder = function (v1, //top left front vecotr.\n    v2, // bottom right back vector.\n    chart, index, type, stroke, fill, strokeThickness, opacity, name, parent) {\n        var i = 0; //cylinder path count.\n        var offsetX;\n        var offsetY;\n        var offsetZ;\n        var vectorCollection;\n        var pathCount = 24;\n        var theta = 360 / pathCount;\n        var degreeToRadian = Math.PI / 180;\n        var centerZ = (v1.z + v2.z) / 2;\n        var result = [];\n        var outPoints = [];\n        var topVector = [];\n        var bottomVector = [];\n        var radiusB = (v2.y - v1.y) < (v2.z - v1.z) ? (v2.y - v1.y) / 2 : (v2.z - v1.z) / 2;\n        var radiusC = (v2.x - v1.x) < (v2.z - v1.z) ? (v2.x - v1.x) / 2 : (v2.z - v1.z) / 2;\n        var centerX = (v1.x + v2.x) / 2;\n        var centerY = (v1.y + v2.y) / 2;\n        switch (type) {\n            case 'Bar':\n            case 'StackingBar':\n            case 'StackingBar100':\n                pathCount++;\n                while (pathCount--) {\n                    offsetY = centerY + radiusB * Math.cos((i * theta) * degreeToRadian);\n                    offsetZ = centerZ + radiusB * Math.sin((i * theta) * degreeToRadian);\n                    outPoints[i] = { Y: offsetY, Z: offsetZ };\n                    topVector.push(this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z));\n                    bottomVector.push(this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z));\n                    if (i > 0) {\n                        vectorCollection = [\n                            this.vector.vector3D(v1.x, outPoints[i - 1].Y, outPoints[i - 1].Z),\n                            this.vector.vector3D(v2.x, outPoints[i - 1].Y, outPoints[i - 1].Z),\n                            this.vector.vector3D(v2.x, outPoints[i].Y, outPoints[i].Z),\n                            this.vector.vector3D(v1.x, outPoints[i].Y, outPoints[i].Z)\n                        ];\n                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, ('-' + (i + 1).toString() + '-' + name), parent);\n                        graphics.addVisual(result[i + 1], chart);\n                    }\n                    i++;\n                }\n                break;\n            case 'Column':\n            case 'StackingColumn':\n            case 'StackingColumn100':\n                pathCount++;\n                while (pathCount--) {\n                    offsetX = centerX + radiusC * Math.cos((i * theta) * degreeToRadian);\n                    offsetZ = centerZ + radiusC * Math.sin((i * theta) * degreeToRadian);\n                    outPoints[i] = { Y: offsetX, Z: offsetZ };\n                    topVector.push(this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z));\n                    bottomVector.push(this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z));\n                    if (i > 0) {\n                        vectorCollection = [\n                            this.vector.vector3D(outPoints[i - 1].Y, v1.y, outPoints[i - 1].Z),\n                            this.vector.vector3D(outPoints[i - 1].Y, v2.y, outPoints[i - 1].Z),\n                            this.vector.vector3D(outPoints[i].Y, v2.y, outPoints[i].Z),\n                            this.vector.vector3D(outPoints[i].Y, v1.y, outPoints[i].Z)\n                        ];\n                        result[i + 1] = this.polygon3D(vectorCollection, chart, index, fill, 0, opacity, fill, '-' + (i + 1).toString() + '-' + name, parent);\n                        graphics.addVisual(result[i + 1], chart);\n                    }\n                    i++;\n                }\n                break;\n            default:\n                break;\n        }\n        result[0] = this.polygon3D(bottomVector, chart, index, stroke, 0, opacity, fill, '-0-' + name, parent);\n        result[1] = this.polygon3D(topVector, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent);\n        graphics.addVisual(result[0], chart);\n        graphics.addVisual(result[1], chart);\n        return result;\n    };\n    /**\n     * Creates a 3D box based on the given vectors, chart, and styling parameters.\n     *\n     * @param {Vector} v1 - The start vector of the box.\n     * @param {Vector} v2 - The end vector of the box.\n     * @param {Chart3D} chart - The 3D chart to which the box belongs.\n     * @param {number} index - The index of the box.\n     * @param {string} stroke - The stroke color of the box.\n     * @param {string} fill - The fill color of the box.\n     * @param {number} strokeThickness - The thickness of the stroke.\n     * @param {number} opacity - The opacity of the box.\n     * @param {boolean} inverse - A boolean indicating whether to inverse the box.\n     * @param {string} name - The name of the box.\n     * @param {Element} parent - The parent element of the box.\n     * @param {string} [text] - Optional text associated with the box.\n     * @returns {Chart3DPolygon[]} - Returns an array of polygons representing the 3D box.\n     *\n     */\n    Polygon3D.prototype.createBox = function (v1, //top left front vecotr.\n    v2, // bottom right back vector.\n    chart, index, stroke, fill, strokeThickness, opacity, inverse, name, parent, text) {\n        var result = [];\n        var point1 = [\n            this.vector.vector3D(v1.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point2 = [\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v2.z)\n        ];\n        var point3 = [\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v1.x, v1.y, v1.z)\n        ];\n        var point4 = [\n            this.vector.vector3D(v1.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point5 = [\n            this.vector.vector3D(v1.x, v1.y, v1.z),\n            this.vector.vector3D(v1.x, v1.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v2.z),\n            this.vector.vector3D(v1.x, v2.y, v1.z)\n        ];\n        var point6 = [\n            this.vector.vector3D(v2.x, v1.y, v1.z),\n            this.vector.vector3D(v2.x, v1.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v2.z),\n            this.vector.vector3D(v2.x, v2.y, v1.z)\n        ];\n        if (name) {\n            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + name, parent, text);\n            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + name, parent, text);\n            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + name, parent, text);\n            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + name, parent, text);\n            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + name, parent, text);\n            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + name, parent, text);\n        }\n        else {\n            result[0] = this.polygon3D(point1, chart, index, stroke, strokeThickness, opacity, fill, '-0-' + index, parent, text);\n            result[1] = this.polygon3D(point2, chart, index, stroke, strokeThickness, opacity, fill, '-1-' + index, parent, text);\n            result[2] = this.polygon3D(point3, chart, index, stroke, strokeThickness, opacity, fill, '-2-' + index, parent, text);\n            result[3] = this.polygon3D(point4, chart, index, stroke, strokeThickness, opacity, fill, '-3-' + index, parent, text);\n            result[4] = this.polygon3D(point5, chart, index, stroke, strokeThickness, opacity, fill, '-4-' + index, parent, text);\n            result[5] = this.polygon3D(point6, chart, index, stroke, strokeThickness, opacity, fill, '-5-' + index, parent, text);\n        }\n        if (inverse) {\n            graphics.addVisual(result[0], chart);\n            graphics.addVisual(result[1], chart);\n            graphics.addVisual(result[2], chart);\n            graphics.addVisual(result[3], chart);\n            graphics.addVisual(result[4], chart);\n            graphics.addVisual(result[5], chart);\n        }\n        else {\n            graphics.addVisual(result[5], chart);\n            graphics.addVisual(result[4], chart);\n            graphics.addVisual(result[0], chart);\n            graphics.addVisual(result[1], chart);\n            graphics.addVisual(result[2], chart);\n            graphics.addVisual(result[3], chart);\n        }\n        return result;\n    };\n    /**\n     * Calculates the normal vector for a 3D polygon based on the provided points.\n     *\n     * @param {...Vector} args - Variable number of vector3d arguments representing points of the polygon.\n     * @returns {void}\n     */\n    Polygon3D.prototype.calculateNormal = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length >= 3) {\n            // Relative information of the points\n            var vector1 = args[0];\n            var vector2 = args[1];\n            var vector3 = args[2];\n            var vector4 = this.vector.vector3DMinus(vector1, vector2);\n            var vector5 = this.vector.vector3DMinus(vector3, vector2);\n            var normal = this.vector.vector3DMultiply(vector4, vector5);\n            var length_1 = this.vector.getLength(normal); // Get length of the vector\n            if (length_1 < this.epsilon) {\n                length_1 = 1;\n            }\n            this.normal = this.vector.vector3D(normal.x / length_1, normal.y / length_1, normal.z / length_1); // Calculate normalization of the vector\n            this.d = -(this.normal.x * vector1.x + this.normal.y * vector1.y + this.normal.z * vector1.z); // Normalized values * 1st coordinates Coordinates - Depth of the plan\n            if (args[3]) {\n                args[3].normal = this.normal;\n                args[3].d = this.d;\n            }\n        }\n        else {\n            var Points = args[0];\n            this.calculateNormal(Points[0], Points[1], Points[2], arguments[1]);\n            for (var i = 3; (i < Points.length) && (this.test()); i++) {\n                this.calculateNormal(Points[i], Points[0], Points[i / 2]);\n            }\n        }\n    };\n    /**\n     * Tests whether the calculated normal vector is valid.\n     *\n     * @returns {boolean} - Returns true if the normal vector is valid, false otherwise.\n     */\n    Polygon3D.prototype.test = function () {\n        return !this.vector.isValid(this.normal);\n    };\n    /**\n     * Transforms the vector points of the specified polygon using the provided matrix.\n     *\n     * @param {number[][]} matrix - The transformation matrix.\n     * @param {Chart3DPolygon} polygon - The polygon to transform.\n     * @returns {void}\n     */\n    Polygon3D.prototype.transform = function (matrix, polygon) {\n        if (polygon.points != null) {\n            for (var i = 0; i < polygon.points.length; i++) {\n                polygon.vectorPoints[i] = polygon.points[i] =\n                    matrixObj.getMatrixVectorMultiple(matrix, polygon.points[i]);\n            }\n            this.calculateNormal(polygon.vectorPoints, polygon);\n        }\n    };\n    /**\n     *  Gets the normal vector based on the transformed points using the specified transformation matrix.\n     *\n     * @param {number[][]} transform - The transformation matrix.\n     * @param {Chart3DVector[]} [vectorPoints] - The vector points.\n     * @returns {Chart3DVector} - Returns the normal vector.\n     * @private\n     */\n    Polygon3D.prototype.getNormal = function (transform, vectorPoints) {\n        var normal;\n        if (vectorPoints != null) {\n            normal = this.vector.getNormal(this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]), matrixObj.getMatrixVectorMultiple(transform, vectorPoints[1]), this.matrixObj.getMatrixVectorMultiple(transform, vectorPoints[2]));\n            for (var i = 3; (i < vectorPoints.length) && !this.vector.isValid(normal) && vectorPoints[i / 2]; i++) {\n                var v1 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i]);\n                var v2 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[0]);\n                var v3 = matrixObj.getMatrixVectorMultiple(transform, vectorPoints[i / 2]);\n                normal = this.vector.getNormal(v1, v2, v3);\n            }\n        }\n        else {\n            normal = matrixObj.getMatrixVectorAnd(transform);\n            this.vector.normalize();\n        }\n        return normal;\n    };\n    /**\n     * A method for creating text element.\n     *\n     * @param {Vector} position - text position.\n     * @param {Chart3DLabelElement} element - text element.\n     * @param {number} xLength - text element x value.\n     * @param {number} yLength - text element y value.\n     * @returns {Chart3DPolygon} - Returns the polygon.\n     */\n    Polygon3D.prototype.createTextElement = function (position, element, xLength, yLength) {\n        var vectorCollection = [];\n        var x = position.x;\n        var y = position.y;\n        var desiredWidth = element.width;\n        var desiredHeight = element.height;\n        vectorCollection[0] = this.vector.vector3D(x, y, position.z);\n        vectorCollection[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLength, position.z);\n        vectorCollection[2] = this.vector.vector3D(x + desiredWidth + xLength, y + desiredHeight + yLength, position.z);\n        return this.text3D(element, vectorCollection);\n    };\n    /**\n     * Draws a template on the specified 3D chart panel.\n     *\n     * @param {PChart3DPolygon} panel - The 3D polygon representing the panel on which the template will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawLine = function (panel, chart) {\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition1 = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var actual3DPosition2 = chart.transform3D.toScreen(panel.vectorPoints[2], transform);\n        var optionsLine = {\n            'id': panel.element.id,\n            'x1': actual3DPosition1.x,\n            'y1': actual3DPosition1.y,\n            'x2': actual3DPosition2.x,\n            'y2': actual3DPosition2.y,\n            'stroke-dasharray': '',\n            'stroke-width': panel.element.width,\n            'stroke': panel.element.stroke,\n            'opacity': panel.element.opacity\n        };\n        chart.chart3D.appendChild(chart.svgRenderer.drawLine(optionsLine));\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(optionsLine.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = optionsLine.id;\n    };\n    /**\n     * Draws text on the specified 3D chart panel.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawTemplate = function (panel, chart) {\n        var element = panel.element;\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var label = element.label;\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        chart.dataLabel3DModule.createDataLabelTemplate(label.series.dataLabelElement, label.series, label.series.dataLabel, label.series.visiblePoints[label.pointIndex], element.argsData, label.pointIndex, false, actual3DPosition);\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a three-dimensional series.\n     *\n     * @param {Chart3DPolygon} panel - The 3D polygon representing the panel on which the text will be drawn.\n     * @param {Chart3D} chart - The 3D chart to which the panel belongs.\n     * @returns {void}\n     */\n    Polygon3D.prototype.drawText = function (panel, chart) {\n        var element = panel.element;\n        var transform = chart3DRender.transform;\n        if (transform == null) {\n            return;\n        }\n        var actual3DPosition = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n        var x = actual3DPosition.x;\n        var y = actual3DPosition.y;\n        if (element.tag === 'text') {\n            var options = {\n                'id': element.id,\n                'x': x,\n                'y': y,\n                'fill': element.font.color || element.fill,\n                'font-size': element.font.size,\n                'font-family': element.font.fontFamily,\n                'font-style': element.font.fontStyle,\n                'font-weight': element.font.fontWeight,\n                'opacity': element.font.opacity,\n                'text-anchor': element.textAnchor,\n                'cursor': 'default',\n                'transform': element.angle ? 'rotate(' + element.angle + ',' + (x) + ',' + y + ')' : ''\n            };\n            var textElement = chart.svg3DRenderer.drawText(options, element.label.text, panel.element.font, chart);\n            if (element.id.indexOf('-axis-title') > -1) {\n                textElement.setAttribute('aria-hidden', 'true');\n            }\n            chart.chart3D.append(textElement);\n        }\n        else {\n            var series = element.series;\n            var labelFormat = (series.yAxis && series.yAxis.labelFormat) ? series.yAxis.labelFormat : '';\n            var pointText = (element.point.text) ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);\n            var textOffset = measureText(pointText, series.dataLabel.font, chart.themeStyle.datalabelFont);\n            var margin = series.dataLabel.margin;\n            var width = textOffset.width + margin.left + margin.right;\n            var height = textOffset.height + margin.top + margin.bottom;\n            var location_1 = { x: actual3DPosition.x, y: actual3DPosition.y };\n            var xXalue = location_1.x - (margin.left) / 2 + (margin.right) / 2;\n            var yValue = location_1.y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;\n            var seriesIndex = series.index;\n            this.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, chart);\n        }\n    };\n    /**\n     * Draws a data label symbol for a specific data point in a three-dimensional series.\n     *\n     * @param {number} seriesIndex - The index of the series to which the data point belongs.\n     * @param {Chart3DSeries} series - The three-dimensional series containing the data point.\n     * @param {number} pointIndex - The index of the data point within the series.\n     * @param {number} x - The x-coordinate of the center of the symbol.\n     * @param {number} y - The y-coordinate of the center of the symbol.\n     * @param {number} width - The width of the symbol.\n     * @param {number} height - The height of the symbol.\n     * @param {Chart3D} chart - The three-dimensional chart containing the series.\n     * @returns {void}\n     */\n    Polygon3D.prototype.dataLabelSymbol = function (seriesIndex, series, pointIndex, x, y, width, height, chart) {\n        var path = 'M' + ' ' + (x + (-width / 2)) + ' ' +\n            (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (-height / 2)) + ' ' + 'L' + ' ' + (x + (width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (height / 2)) + ' ' + 'L' + ' ' + (x + (-width / 2)) +\n            ' ' + (y + (-height / 2)) + ' z';\n        var Rectoptions = {\n            id: chart.element.id + '-svg' + '-data-label-series-' + seriesIndex + '-point-' + pointIndex,\n            fill: series.dataLabel.fill,\n            'stroke-width': series.dataLabel.border.width,\n            'stroke-dasharray': series.dataLabel.border.dashArray,\n            stroke: series.dataLabel.border.color,\n            opacity: series.dataLabel.opacity,\n            visibility: '',\n            d: path\n        };\n        var element = chart.svgRenderer.drawPath(Rectoptions);\n        chart.chart3D.append(element);\n    };\n    /**\n     * Draws a three-dimensional polygon on the specified chart.\n     *\n     * @param {PChart3DPolygon} panel - The polygon to be drawn.\n     * @param {Chart3D} chart - The three-dimensional chart on which the polygon is to be drawn.\n     * @returns {void}\n     */\n    Polygon3D.prototype.draw = function (panel, chart) {\n        if (panel.vectorPoints == null || panel.vectorPoints.length <= 0) {\n            return;\n        }\n        var transform = chart3DRender.transform;\n        var pathDirection = chart.svg3DRenderer.getStringBuilder();\n        var color = panel.fill;\n        var format = chart.svg3DRenderer.checkColorFormat(color);\n        if (!format) {\n            if (color !== 'transparent') {\n                color = colorNameToHex(color);\n            }\n        }\n        var figure = { StartPoint: null };\n        if (transform != null) {\n            figure.StartPoint = chart.transform3D.toScreen(panel.vectorPoints[0], transform);\n            pathDirection.append('M' + ' ' + (figure.StartPoint.x) + ' ' + (figure.StartPoint.y) + ' ');\n            for (var i = 0; i < panel.vectorPoints.length; i++) {\n                var lineSegment = chart.transform3D.toScreen(panel.vectorPoints[i], transform);\n                pathDirection.append('L' + ' ' + (lineSegment.x) + ' ' + (lineSegment.y) + ' ');\n            }\n        }\n        var direction = pathDirection.toString();\n        var name = 'Light';\n        var lightCoefficientZ = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 0, 1))) - 1));\n        var lightCoefficientY = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(0, 1, 0))) - 1));\n        var lightCoefficientX = (2 * (Math.abs(this.vector.vector3DAdd(panel.normal, this.vector.vector3D(1, 0, 0))) - 1));\n        if (panel.name && !(panel.name.indexOf('-wall-brush') > -1)) {\n            if (lightCoefficientZ === lightCoefficientX) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else if (((lightCoefficientY === lightCoefficientZ) || (lightCoefficientZ !== 0 && lightCoefficientY < lightCoefficientZ))) {\n                name = 'XLight';\n                color = this.applyXLight(color, chart);\n            }\n            else if (lightCoefficientZ < 0) {\n                name = 'ZLight';\n                color = this.applyZLight(color, chart);\n            }\n            else {\n                name = 'Light';\n            }\n        }\n        var options = {\n            'id': chart.element.id + '-svg' + panel.name,\n            'name': name,\n            'fill': color,\n            'stroke': '',\n            'stroke-width': panel.strokeThickness,\n            'opacity': panel.opacity,\n            'd': direction\n        };\n        var element = chart.svgRenderer.drawPath(options);\n        if (panel.text) {\n            element.setAttribute('aria-label', panel.text);\n            element.setAttribute('role', 'img');\n        }\n        if (panel.name && panel.name.indexOf('-wall-brush') > -1) {\n            element.setAttribute('aria-hidden', 'true');\n        }\n        if (element.id.indexOf('0-region-series-0-point-0') > -1) {\n            if (this.tabIndex) {\n                element.setAttribute('tabindex', '0');\n            }\n            else {\n                var elements = panel.polygonElement.parent.querySelectorAll('[id*=\"0-region-series-0-point-0\"]');\n                if (elements.length > 0) {\n                    elements[elements.length - 1].removeAttribute('tabindex');\n                }\n                element.setAttribute('tabindex', '0');\n            }\n            this.tabIndex = false;\n        }\n        appendChildElement(false, panel.polygonElement.parent, element, chart.redraw, true, 'x', 'y', null, direction);\n        if (chart.previousID && chart.isTouch) {\n            var previousElement = document.getElementById(chart.previousID);\n            var currentElement = document.getElementById(options.id);\n            if (previousElement && currentElement) {\n                currentElement.parentNode.insertBefore(currentElement, previousElement.nextSibling);\n            }\n        }\n        chart.previousID = options.id;\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green and blue components.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    Polygon3D.prototype.applyXLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.7).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.7).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.7).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    /**\n     * Applies a lightening effect to the given color by reducing its red, green and blue components with a focus on the Z-axis.\n     *\n     * @param {string} color - The input color in hexadecimal format.\n     * @param {Chart3D} chart - The three-dimensional chart associated with the color.\n     * @returns {string} - The lightened color in hexadecimal format.\n     */\n    Polygon3D.prototype.applyZLight = function (color, chart) {\n        var RGB = chart.svg3DRenderer.hexToValue(color);\n        RGB.red = parseInt((RGB.red * 0.9).toString(), 10);\n        RGB.green = parseInt((RGB.green * 0.9).toString(), 10);\n        RGB.blue = parseInt((RGB.blue * 0.9).toString(), 10);\n        return chart.svg3DRenderer.hexColor(RGB);\n    };\n    return Polygon3D;\n}());\nexport { Polygon3D };\nvar vector = new Vector3D(0, 0, 0);\nvar matrixObj = new Matrix3D();\nvar bspTreeObj = new BinaryTreeBuilder();\nvar polygonObj = new Polygon3D();\nvar graphics = new Graphics3D();\n/**\n * Gets the minimum delta value between adjacent data points on a given axis in a three-dimensional chart.\n *\n * @param {Chart3DAxis} axis - The three-dimensional axis for which the delta value is calculated.\n * @param {Chart3DSeries[]} seriesCollection - Collection of three-dimensional series in the chart.\n * @returns {number} - The minimum delta value between adjacent data points on the specified axis.\n */\nexport function getMinPointsDeltaValue(axis, seriesCollection) {\n    var minDelta = Number.MAX_VALUE;\n    var xValues;\n    var minVal;\n    var seriesMin;\n    for (var index = 0; index < seriesCollection.length; index++) {\n        var series = seriesCollection[index];\n        xValues = [];\n        if (series.visible &&\n            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null))) {\n            xValues = series.points.map(function (point) {\n                return point.xValue;\n            });\n            xValues.sort(function (first, second) { return first - second; });\n            if (xValues.length === 1) {\n                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - 25920000) : series.xMin;\n                minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ?\n                    seriesMin : axis.visibleRange.min);\n                if (minVal !== 0) {\n                    minDelta = Math.min(minDelta, minVal);\n                }\n            }\n            else {\n                for (var index_1 = 0; index_1 < xValues.length; index_1++) {\n                    var value = xValues[index_1];\n                    if (index_1 > 0 && value) {\n                        minVal = value - xValues[index_1 - 1];\n                        if (minVal !== 0) {\n                            minDelta = Math.min(minDelta, minVal);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (minDelta === Number.MAX_VALUE) {\n        minDelta = 1;\n    }\n    return minDelta;\n}\n/**\n * Converts a numeric value to a coefficient based on the given 3D axis.\n *\n * @param {number} value - The numeric value to be converted.\n * @param {Chart3DAxis} axis - The 3D axis for reference.\n * @returns {number} - The coefficient value.\n * @private\n */\nexport function valueToCoefficients(value, axis) {\n    var range = axis.visibleRange;\n    var result = (value - range.min) / (range.delta);\n    var isInverse = axis.isAxisInverse;\n    return isInverse ? (1 - result) : result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}