{"ast":null,"code":"import { isNullOrUndefined, getValue, extend, isBlazor } from './util';\nvar Observer = /** @class */function () {\n  function Observer(context) {\n    this.ranArray = [];\n    this.boundedEvents = {};\n    if (isNullOrUndefined(context)) {\n      return;\n    }\n    this.context = context;\n  }\n  /**\n   * To attach handler for given property in current context.\n   *\n   * @param {string} property - specifies the name of the event.\n   * @param {Function} handler - Specifies the handler function to be called while event notified.\n   * @param {Object} context - Specifies the context binded to the handler.\n   * @param {string} id - specifies the random generated id.\n   * @returns {void}\n   */\n  Observer.prototype.on = function (property, handler, context, id) {\n    if (isNullOrUndefined(handler)) {\n      return;\n    }\n    var cntxt = context || this.context;\n    if (this.notExist(property)) {\n      this.boundedEvents[\"\" + property] = [{\n        handler: handler,\n        context: cntxt,\n        id: id\n      }];\n      return;\n    }\n    if (!isNullOrUndefined(id)) {\n      if (this.ranArray.indexOf(id) === -1) {\n        this.ranArray.push(id);\n        this.boundedEvents[\"\" + property].push({\n          handler: handler,\n          context: cntxt,\n          id: id\n        });\n      }\n    } else if (!this.isHandlerPresent(this.boundedEvents[\"\" + property], handler)) {\n      this.boundedEvents[\"\" + property].push({\n        handler: handler,\n        context: cntxt\n      });\n    }\n  };\n  /**\n   * To remove handlers from a event attached using on() function.\n   *\n   * @param {string} property - specifies the name of the event.\n   * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.\n   * @param {string} id - specifies the random generated id.\n   * @returns {void} ?\n   */\n  Observer.prototype.off = function (property, handler, id) {\n    if (this.notExist(property)) {\n      return;\n    }\n    var curObject = getValue(property, this.boundedEvents);\n    if (handler) {\n      for (var i = 0; i < curObject.length; i++) {\n        if (id) {\n          if (curObject[parseInt(i.toString(), 10)].id === id) {\n            curObject.splice(i, 1);\n            var indexLocation = this.ranArray.indexOf(id);\n            if (indexLocation !== -1) {\n              this.ranArray.splice(indexLocation, 1);\n            }\n            break;\n          }\n        } else if (handler === curObject[parseInt(i.toString(), 10)].handler) {\n          curObject.splice(i, 1);\n          break;\n        }\n      }\n    } else {\n      delete this.boundedEvents[\"\" + property];\n    }\n  };\n  /**\n   * To notify the handlers in the specified event.\n   *\n   * @param {string} property - Specifies the event to be notify.\n   * @param {Object} argument - Additional parameters to pass while calling the handler.\n   * @param {Function} successHandler - this function will invoke after event successfully triggered\n   * @param {Function} errorHandler - this function will invoke after event if it was failure to call.\n   * @returns {void} ?\n   */\n  Observer.prototype.notify = function (property, argument, successHandler, errorHandler) {\n    if (this.notExist(property)) {\n      if (successHandler) {\n        successHandler.call(this, argument);\n      }\n      return;\n    }\n    if (argument) {\n      argument.name = property;\n    }\n    var blazor = 'Blazor';\n    var curObject = getValue(property, this.boundedEvents).slice(0);\n    if (window[\"\" + blazor]) {\n      return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);\n    } else {\n      for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {\n        var cur = curObject_1[_i];\n        cur.handler.call(cur.context, argument);\n      }\n      if (successHandler) {\n        successHandler.call(this, argument);\n      }\n    }\n  };\n  Observer.prototype.blazorCallback = function (objs, argument, successHandler, errorHandler, index) {\n    var _this = this;\n    var isTrigger = index === objs.length - 1;\n    if (index < objs.length) {\n      var obj_1 = objs[parseInt(index.toString(), 10)];\n      var promise = obj_1.handler.call(obj_1.context, argument);\n      if (promise && typeof promise.then === 'function') {\n        if (!successHandler) {\n          return promise;\n        }\n        promise.then(function (data) {\n          data = typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;\n          extend(argument, argument, data, true);\n          if (successHandler && isTrigger) {\n            successHandler.call(obj_1.context, argument);\n          } else {\n            return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n          }\n        }).catch(function (data) {\n          if (errorHandler) {\n            errorHandler.call(obj_1.context, typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);\n          }\n        });\n      } else if (successHandler && isTrigger) {\n        successHandler.call(obj_1.context, argument);\n      } else {\n        return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n      }\n    }\n  };\n  // eslint-disable-next-line\n  Observer.prototype.dateReviver = function (key, value) {\n    var dPattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;\n    if (isBlazor && typeof value === 'string' && value.match(dPattern) !== null) {\n      return new Date(value);\n    }\n    return value;\n  };\n  Observer.prototype.isJson = function (value) {\n    try {\n      JSON.parse(value);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n  /**\n   * To destroy handlers in the event\n   *\n   * @returns {void} ?\n   */\n  Observer.prototype.destroy = function () {\n    this.boundedEvents = this.context = undefined;\n  };\n  /**\n   * To remove internationalization events\n   *\n   * @returns {void} ?\n   */\n  Observer.prototype.offIntlEvents = function () {\n    // eslint-disable-next-line\n    var eventsArr = this.boundedEvents['notifyExternalChange'];\n    if (eventsArr) {\n      for (var i = 0; i < eventsArr.length; i++) {\n        // eslint-disable-next-line\n        var curContext = eventsArr[\"\" + i].context;\n        if (curContext && curContext.detectFunction && curContext.randomId && !curContext.isRendered) {\n          this.off('notifyExternalChange', curContext.detectFunction, curContext.randomId);\n          i--;\n        }\n      }\n      if (!this.boundedEvents['notifyExternalChange'].length) {\n        delete this.boundedEvents['notifyExternalChange'];\n      }\n    }\n  };\n  /**\n   * Returns if the property exists.\n   *\n   * @param {string} prop ?\n   * @returns {boolean} ?\n   */\n  Observer.prototype.notExist = function (prop) {\n    // eslint-disable-next-line\n    return this.boundedEvents.hasOwnProperty(prop) === false || this.boundedEvents[prop].length <= 0;\n  };\n  /**\n   * Returns if the handler is present.\n   *\n   * @param {BoundOptions[]} boundedEvents ?\n   * @param {Function} handler ?\n   * @returns {boolean} ?\n   */\n  Observer.prototype.isHandlerPresent = function (boundedEvents, handler) {\n    for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {\n      var cur = boundedEvents_1[_i];\n      if (cur.handler === handler) {\n        return true;\n      }\n    }\n    return false;\n  };\n  return Observer;\n}();\nexport { Observer };","map":{"version":3,"names":["isNullOrUndefined","getValue","extend","isBlazor","Observer","context","ranArray","boundedEvents","prototype","on","property","handler","id","cntxt","notExist","indexOf","push","isHandlerPresent","off","curObject","i","length","parseInt","toString","splice","indexLocation","notify","argument","successHandler","errorHandler","call","name","blazor","slice","window","blazorCallback","_i","curObject_1","cur","objs","index","_this","isTrigger","obj_1","promise","then","data","isJson","JSON","parse","dateReviver","catch","key","value","dPattern","match","Date","e","destroy","undefined","offIntlEvents","eventsArr","curContext","detectFunction","randomId","isRendered","prop","hasOwnProperty","boundedEvents_1"],"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/@syncfusion/ej2-base/src/observer.js"],"sourcesContent":["import { isNullOrUndefined, getValue, extend, isBlazor } from './util';\nvar Observer = /** @class */ (function () {\n    function Observer(context) {\n        this.ranArray = [];\n        this.boundedEvents = {};\n        if (isNullOrUndefined(context)) {\n            return;\n        }\n        this.context = context;\n    }\n    /**\n     * To attach handler for given property in current context.\n     *\n     * @param {string} property - specifies the name of the event.\n     * @param {Function} handler - Specifies the handler function to be called while event notified.\n     * @param {Object} context - Specifies the context binded to the handler.\n     * @param {string} id - specifies the random generated id.\n     * @returns {void}\n     */\n    Observer.prototype.on = function (property, handler, context, id) {\n        if (isNullOrUndefined(handler)) {\n            return;\n        }\n        var cntxt = context || this.context;\n        if (this.notExist(property)) {\n            this.boundedEvents[\"\" + property] = [{ handler: handler, context: cntxt, id: id }];\n            return;\n        }\n        if (!isNullOrUndefined(id)) {\n            if (this.ranArray.indexOf(id) === -1) {\n                this.ranArray.push(id);\n                this.boundedEvents[\"\" + property].push({ handler: handler, context: cntxt, id: id });\n            }\n        }\n        else if (!this.isHandlerPresent(this.boundedEvents[\"\" + property], handler)) {\n            this.boundedEvents[\"\" + property].push({ handler: handler, context: cntxt });\n        }\n    };\n    /**\n     * To remove handlers from a event attached using on() function.\n     *\n     * @param {string} property - specifies the name of the event.\n     * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.\n     * @param {string} id - specifies the random generated id.\n     * @returns {void} ?\n     */\n    Observer.prototype.off = function (property, handler, id) {\n        if (this.notExist(property)) {\n            return;\n        }\n        var curObject = getValue(property, this.boundedEvents);\n        if (handler) {\n            for (var i = 0; i < curObject.length; i++) {\n                if (id) {\n                    if (curObject[parseInt(i.toString(), 10)].id === id) {\n                        curObject.splice(i, 1);\n                        var indexLocation = this.ranArray.indexOf(id);\n                        if (indexLocation !== -1) {\n                            this.ranArray.splice(indexLocation, 1);\n                        }\n                        break;\n                    }\n                }\n                else if (handler === curObject[parseInt(i.toString(), 10)].handler) {\n                    curObject.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        else {\n            delete this.boundedEvents[\"\" + property];\n        }\n    };\n    /**\n     * To notify the handlers in the specified event.\n     *\n     * @param {string} property - Specifies the event to be notify.\n     * @param {Object} argument - Additional parameters to pass while calling the handler.\n     * @param {Function} successHandler - this function will invoke after event successfully triggered\n     * @param {Function} errorHandler - this function will invoke after event if it was failure to call.\n     * @returns {void} ?\n     */\n    Observer.prototype.notify = function (property, argument, successHandler, errorHandler) {\n        if (this.notExist(property)) {\n            if (successHandler) {\n                successHandler.call(this, argument);\n            }\n            return;\n        }\n        if (argument) {\n            argument.name = property;\n        }\n        var blazor = 'Blazor';\n        var curObject = getValue(property, this.boundedEvents).slice(0);\n        if (window[\"\" + blazor]) {\n            return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);\n        }\n        else {\n            for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {\n                var cur = curObject_1[_i];\n                cur.handler.call(cur.context, argument);\n            }\n            if (successHandler) {\n                successHandler.call(this, argument);\n            }\n        }\n    };\n    Observer.prototype.blazorCallback = function (objs, argument, successHandler, errorHandler, index) {\n        var _this = this;\n        var isTrigger = index === objs.length - 1;\n        if (index < objs.length) {\n            var obj_1 = objs[parseInt(index.toString(), 10)];\n            var promise = obj_1.handler.call(obj_1.context, argument);\n            if (promise && typeof promise.then === 'function') {\n                if (!successHandler) {\n                    return promise;\n                }\n                promise.then(function (data) {\n                    data = typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;\n                    extend(argument, argument, data, true);\n                    if (successHandler && isTrigger) {\n                        successHandler.call(obj_1.context, argument);\n                    }\n                    else {\n                        return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n                    }\n                }).catch(function (data) {\n                    if (errorHandler) {\n                        errorHandler.call(obj_1.context, typeof data === 'string' &&\n                            _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);\n                    }\n                });\n            }\n            else if (successHandler && isTrigger) {\n                successHandler.call(obj_1.context, argument);\n            }\n            else {\n                return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);\n            }\n        }\n    };\n    // eslint-disable-next-line\n    Observer.prototype.dateReviver = function (key, value) {\n        var dPattern = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;\n        if (isBlazor && typeof value === 'string' && value.match(dPattern) !== null) {\n            return (new Date(value));\n        }\n        return (value);\n    };\n    Observer.prototype.isJson = function (value) {\n        try {\n            JSON.parse(value);\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * To destroy handlers in the event\n     *\n     * @returns {void} ?\n     */\n    Observer.prototype.destroy = function () {\n        this.boundedEvents = this.context = undefined;\n    };\n    /**\n     * To remove internationalization events\n     *\n     * @returns {void} ?\n     */\n    Observer.prototype.offIntlEvents = function () {\n        // eslint-disable-next-line\n        var eventsArr = this.boundedEvents['notifyExternalChange'];\n        if (eventsArr) {\n            for (var i = 0; i < eventsArr.length; i++) {\n                // eslint-disable-next-line\n                var curContext = eventsArr[\"\" + i].context;\n                if (curContext && curContext.detectFunction && curContext.randomId && !curContext.isRendered) {\n                    this.off('notifyExternalChange', curContext.detectFunction, curContext.randomId);\n                    i--;\n                }\n            }\n            if (!this.boundedEvents['notifyExternalChange'].length) {\n                delete this.boundedEvents['notifyExternalChange'];\n            }\n        }\n    };\n    /**\n     * Returns if the property exists.\n     *\n     * @param {string} prop ?\n     * @returns {boolean} ?\n     */\n    Observer.prototype.notExist = function (prop) {\n        // eslint-disable-next-line\n        return this.boundedEvents.hasOwnProperty(prop) === false || this.boundedEvents[prop].length <= 0;\n    };\n    /**\n     * Returns if the handler is present.\n     *\n     * @param {BoundOptions[]} boundedEvents ?\n     * @param {Function} handler ?\n     * @returns {boolean} ?\n     */\n    Observer.prototype.isHandlerPresent = function (boundedEvents, handler) {\n        for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {\n            var cur = boundedEvents_1[_i];\n            if (cur.handler === handler) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return Observer;\n}());\nexport { Observer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}