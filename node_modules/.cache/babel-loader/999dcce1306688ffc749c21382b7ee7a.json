{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkForGraphConfigChanges = checkForGraphConfigChanges;\nexports.checkForGraphElementsChanges = checkForGraphElementsChanges;\nexports.getCenterAndZoomTransformation = getCenterAndZoomTransformation;\nexports.getId = getId;\nexports.initializeGraphState = initializeGraphState;\nexports.updateNodeHighlightedValue = updateNodeHighlightedValue;\nexports.getNormalizedNodeCoordinates = getNormalizedNodeCoordinates;\nexports.initializeNodes = initializeNodes;\n\nvar _d3Force = require(\"d3-force\");\n\nvar _d3Selection = require(\"d3-selection\");\n\nvar _d3Zoom = require(\"d3-zoom\");\n\nvar _graph2 = _interopRequireDefault(require(\"./graph.const\"));\n\nvar _graph3 = _interopRequireDefault(require(\"./graph.config\"));\n\nvar _err = _interopRequireDefault(require(\"../../err\"));\n\nvar _utils = require(\"../../utils\");\n\nvar _collapse = require(\"./collapse.helper\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar NODE_PROPS_WHITELIST = [\"id\", \"highlighted\", \"x\", \"y\", \"index\", \"vy\", \"vx\"];\nvar LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\n\nfunction _createForceSimulation(width, height, gravity) {\n  var frx = (0, _d3Force.forceX)(width / 2).strength(_graph2[\"default\"].FORCE_X);\n  var fry = (0, _d3Force.forceY)(height / 2).strength(_graph2[\"default\"].FORCE_Y);\n  var forceStrength = gravity;\n  return (0, _d3Force.forceSimulation)().force(\"charge\", (0, _d3Force.forceManyBody)().strength(forceStrength)).force(\"x\", frx).force(\"y\", fry);\n}\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\n\n\nfunction _initializeLinks(graphLinks, config) {\n  return graphLinks.reduce(function (links, l) {\n    var source = getId(l.source);\n    var target = getId(l.target);\n\n    if (!links[source]) {\n      links[source] = {};\n    }\n\n    if (!links[target]) {\n      links[target] = {};\n    }\n\n    var value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n    links[source][target] = value;\n\n    if (!config.directed) {\n      links[target][source] = value;\n    }\n\n    return links;\n  }, {});\n}\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\n\n\nfunction initializeNodes(graphNodes) {\n  var nodes = {};\n  var n = graphNodes.length;\n\n  for (var i = 0; i < n; i++) {\n    var node = graphNodes[i];\n    node.highlighted = false; // if an fx (forced x) is given, we want to use that\n\n    if (Object.prototype.hasOwnProperty.call(node, \"fx\")) {\n      node.x = node.fx;\n    } else if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n      node.x = 0;\n    } // if an fy (forced y) is given, we want to use that\n\n\n    if (Object.prototype.hasOwnProperty.call(node, \"fy\")) {\n      node.y = node.fy;\n    } else if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n      node.y = 0;\n    }\n\n    nodes[node.id.toString()] = node;\n  }\n\n  return nodes;\n}\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\n\n\nfunction _mergeDataLinkWithD3Link(link, index) {\n  var d3Links = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var config = arguments.length > 3 ? arguments[3] : undefined;\n  var state = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {}; // find the matching link if it exists\n\n  var tmp = d3Links.find(function (l) {\n    return l.source.id === link.source && l.target.id === link.target;\n  });\n  var d3Link = tmp && (0, _utils.pick)(tmp, LINK_PROPS_WHITELIST);\n  var customProps = (0, _utils.antiPick)(link, [\"source\", \"target\"]);\n\n  if (d3Link) {\n    var toggledDirected = state.config && Object.prototype.hasOwnProperty.call(state.config, \"directed\") && config.directed !== state.config.directed;\n\n    var refinedD3Link = _objectSpread({\n      index: index\n    }, d3Link, {}, customProps); // every time we toggle directed config all links should be visible again\n\n\n    if (toggledDirected) {\n      return _objectSpread({}, refinedD3Link, {\n        isHidden: false\n      });\n    } // every time we disable collapsible (collapsible is false) all links should be visible again\n\n\n    return config.collapsible ? refinedD3Link : _objectSpread({}, refinedD3Link, {\n      isHidden: false\n    });\n  }\n\n  var highlighted = false;\n  var source = {\n    id: link.source,\n    highlighted: highlighted\n  };\n  var target = {\n    id: link.target,\n    highlighted: highlighted\n  };\n  return _objectSpread({\n    index: index,\n    source: source,\n    target: target\n  }, customProps);\n}\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\n\n\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n  return Object.keys(nodes).reduce(function (acc, nodeId) {\n    var _computeNodeDegree = (0, _collapse.computeNodeDegree)(nodeId, linksMatrix),\n        inDegree = _computeNodeDegree.inDegree,\n        outDegree = _computeNodeDegree.outDegree;\n\n    var node = nodes[nodeId];\n    var taggedNode = inDegree === 0 && outDegree === 0 ? _objectSpread({}, node, {\n      _orphan: true\n    }) : node;\n    acc[nodeId] = taggedNode;\n    return acc;\n  }, {});\n}\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided (not even empty Array)\n * @returns {undefined}\n * @memberof Graph/helper\n */\n\n\nfunction _validateGraphData(data) {\n  if (!data.nodes || !data.nodes.length) {\n    (0, _utils.logWarning)(\"Graph\", _err[\"default\"].INSUFFICIENT_DATA);\n    data.nodes = [];\n  }\n\n  if (!data.links) {\n    (0, _utils.logWarning)(\"Graph\", _err[\"default\"].INSUFFICIENT_LINKS);\n    data.links = [];\n  }\n\n  var n = data.links.length;\n\n  var _loop = function _loop(i) {\n    var l = data.links[i];\n\n    if (!data.nodes.find(function (n) {\n      return n.id === l.source;\n    })) {\n      (0, _utils.throwErr)(\"Graph\", \"\".concat(_err[\"default\"].INVALID_LINKS, \" - \\\"\").concat(l.source, \"\\\" is not a valid source node id\"));\n    }\n\n    if (!data.nodes.find(function (n) {\n      return n.id === l.target;\n    })) {\n      (0, _utils.throwErr)(\"Graph\", \"\".concat(_err[\"default\"].INVALID_LINKS, \" - \\\"\").concat(l.target, \"\\\" is not a valid target node id\"));\n    }\n\n    if (l && l.value !== undefined && typeof l.value !== \"number\") {\n      (0, _utils.throwErr)(\"Graph\", \"\".concat(_err[\"default\"].INVALID_LINK_VALUE, \" - found in link with source \\\"\").concat(l.source, \"\\\" and target \\\"\").concat(l.target, \"\\\"\"));\n    }\n  };\n\n  for (var i = 0; i < n; i++) {\n    _loop(i);\n  }\n} // list of properties that are of no interest when it comes to nodes and links comparison\n\n\nvar NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\n\nfunction _pickId(o) {\n  return (0, _utils.pick)(o, [\"id\"]);\n}\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\n\n\nfunction _pickSourceAndTarget(o) {\n  return (0, _utils.pick)(o, [\"source\", \"target\"]);\n}\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n  var nextNodes = nextProps.data.nodes.map(function (n) {\n    return (0, _utils.antiPick)(n, NODE_PROPERTIES_DISCARD_TO_COMPARE);\n  });\n  var nextLinks = nextProps.data.links;\n  var stateD3Nodes = currentState.d3Nodes.map(function (n) {\n    return (0, _utils.antiPick)(n, NODE_PROPERTIES_DISCARD_TO_COMPARE);\n  });\n  var stateD3Links = currentState.d3Links.map(function (l) {\n    return {\n      source: getId(l.source),\n      target: getId(l.target)\n    };\n  });\n  var graphElementsUpdated = !((0, _utils.isDeepEqual)(nextNodes, stateD3Nodes) && (0, _utils.isDeepEqual)(nextLinks, stateD3Links));\n  var newGraphElements = nextNodes.length !== stateD3Nodes.length || nextLinks.length !== stateD3Links.length || !(0, _utils.isDeepEqual)(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) || !(0, _utils.isDeepEqual)(nextLinks.map(_pickSourceAndTarget), stateD3Links.map(_pickSourceAndTarget));\n  return {\n    graphElementsUpdated: graphElementsUpdated,\n    newGraphElements: newGraphElements\n  };\n}\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n  var newConfig = nextProps.config || {};\n  var configUpdated = newConfig && !(0, _utils.isEmptyObject)(newConfig) && !(0, _utils.isDeepEqual)(newConfig, currentState.config);\n  var d3ConfigUpdated = newConfig && newConfig.d3 && !(0, _utils.isDeepEqual)(newConfig.d3, currentState.config.d3);\n  return {\n    configUpdated: configUpdated,\n    d3ConfigUpdated: d3ConfigUpdated\n  };\n}\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {string} containerElId - ID of container element\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\n\n\nfunction getCenterAndZoomTransformation(d3Node, config, containerElId) {\n  if (!d3Node) {\n    return;\n  }\n\n  var width = config.width,\n      height = config.height,\n      focusZoom = config.focusZoom;\n  var selector = (0, _d3Selection.select)(\"#\".concat(containerElId)); // in order to initialize the new position\n\n  selector.call((0, _d3Zoom.zoom)().transform, _d3Zoom.zoomIdentity.translate(width / 2, height / 2).scale(focusZoom).translate(-d3Node.x, -d3Node.y));\n  return \"\\n    translate(\".concat(width / 2, \", \").concat(height / 2, \")\\n    scale(\").concat(focusZoom, \")\\n    translate(\").concat(-d3Node.x, \", \").concat(-d3Node.y, \")\\n  \");\n}\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\n\n\nfunction getId(sot) {\n  return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\n\n\nfunction initializeGraphState(_ref, state) {\n  var data = _ref.data,\n      id = _ref.id,\n      config = _ref.config;\n\n  _validateGraphData(data);\n\n  var graph;\n\n  if (state && state.nodes) {\n    graph = {\n      nodes: data.nodes.map(function (n) {\n        return state.nodes[n.id] ? _objectSpread({}, n, {}, (0, _utils.pick)(state.nodes[n.id], NODE_PROPS_WHITELIST)) : _objectSpread({}, n);\n      }),\n      links: data.links.map(function (l, index) {\n        return _mergeDataLinkWithD3Link(l, index, state && state.d3Links, config, state);\n      })\n    };\n  } else {\n    graph = {\n      nodes: data.nodes.map(function (n) {\n        return _objectSpread({}, n);\n      }),\n      links: data.links.map(function (l) {\n        return _objectSpread({}, l);\n      })\n    };\n  }\n\n  var newConfig = _objectSpread({}, (0, _utils.merge)(_graph3[\"default\"], config || {})),\n      links = _initializeLinks(graph.links, newConfig),\n      // matrix of graph connections\n  nodes = _tagOrphanNodes(initializeNodes(graph.nodes), links);\n\n  var _graph = graph,\n      d3Nodes = _graph.nodes,\n      d3Links = _graph.links;\n  var formatedId = id.replace(/ /g, \"_\");\n\n  var simulation = _createForceSimulation(newConfig.width, newConfig.height, newConfig.d3 && newConfig.d3.gravity);\n\n  var minZoom = newConfig.minZoom,\n      maxZoom = newConfig.maxZoom,\n      focusZoom = newConfig.focusZoom;\n\n  if (focusZoom > maxZoom) {\n    newConfig.focusZoom = maxZoom;\n  } else if (focusZoom < minZoom) {\n    newConfig.focusZoom = minZoom;\n  }\n\n  return {\n    id: formatedId,\n    config: newConfig,\n    links: links,\n    d3Links: d3Links,\n    nodes: nodes,\n    d3Nodes: d3Nodes,\n    highlightedNode: \"\",\n    simulation: simulation,\n    newGraphElements: false,\n    configUpdated: false,\n    transform: 1,\n    draggedNode: null\n  };\n}\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\n\n\nfunction updateNodeHighlightedValue(nodes, links, config, id) {\n  var value = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var highlightedNode = value ? id : \"\";\n\n  var node = _objectSpread({}, nodes[id], {\n    highlighted: value\n  });\n\n  var updatedNodes = _objectSpread({}, nodes, _defineProperty({}, id, node)); // when highlightDegree is 0 we want only to highlight selected node\n\n\n  if (links[id] && config.highlightDegree !== 0) {\n    updatedNodes = Object.keys(links[id]).reduce(function (acc, linkId) {\n      var updatedNode = _objectSpread({}, updatedNodes[linkId], {\n        highlighted: value\n      });\n\n      acc[linkId] = updatedNode;\n      return acc;\n    }, updatedNodes);\n  }\n\n  return {\n    nodes: updatedNodes,\n    highlightedNode: highlightedNode\n  };\n}\n/**\n * Computes the normalized vector from a vector.\n * @param {Object} vector a 2D vector with x and y components\n * @param {number} vector.x x coordinate\n * @param {number} vector.y y coordinate\n * @returns {Object} normalized vector\n * @memberof Graph/helper\n */\n\n\nfunction normalize(vector) {\n  var norm = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n  return norm === 0 ? vector : {\n    x: vector.x / norm,\n    y: vector.y / norm\n  };\n}\n\nvar SYMBOLS_WITH_OPTIMIZED_POSITIONING = new Set([_graph2[\"default\"].SYMBOLS.CIRCLE]);\n/**\n * Computes new node coordinates to make arrowheads point at nodes.\n * Arrow configuration is only available for circles.\n * @param {Object} info - the couple of nodes we need to compute new coordinates\n * @param {string} info.sourceId - node source id\n * @param {string} info.targetId - node target id\n * @param {Object} info.sourceCoords - node source coordinates\n * @param {Object} info.targetCoords - node target coordinates\n * @param {Object.<string, Object>} nodes - same as {@link #graphrenderer|nodes in renderGraph}.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {number} strokeWidth width of the link stroke\n * @returns {Object} new nodes coordinates\n * @memberof Graph/helper\n */\n\nfunction getNormalizedNodeCoordinates(_ref2, nodes, config, strokeWidth) {\n  var _config$node, _config$node2, _config$node3;\n\n  var sourceId = _ref2.sourceId,\n      targetId = _ref2.targetId,\n      _ref2$sourceCoords = _ref2.sourceCoords,\n      sourceCoords = _ref2$sourceCoords === void 0 ? {} : _ref2$sourceCoords,\n      _ref2$targetCoords = _ref2.targetCoords,\n      targetCoords = _ref2$targetCoords === void 0 ? {} : _ref2$targetCoords;\n  var sourceNode = nodes === null || nodes === void 0 ? void 0 : nodes[sourceId];\n  var targetNode = nodes === null || nodes === void 0 ? void 0 : nodes[targetId];\n\n  if (!sourceNode || !targetNode) {\n    return {\n      sourceCoords: sourceCoords,\n      targetCoords: targetCoords\n    };\n  }\n\n  if (((_config$node = config.node) === null || _config$node === void 0 ? void 0 : _config$node.viewGenerator) || (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.viewGenerator) || (targetNode === null || targetNode === void 0 ? void 0 : targetNode.viewGenerator)) {\n    return {\n      sourceCoords: sourceCoords,\n      targetCoords: targetCoords\n    };\n  }\n\n  var sourceSymbolType = sourceNode.symbolType || ((_config$node2 = config.node) === null || _config$node2 === void 0 ? void 0 : _config$node2.symbolType);\n  var targetSymbolType = targetNode.symbolType || ((_config$node3 = config.node) === null || _config$node3 === void 0 ? void 0 : _config$node3.symbolType);\n\n  if (!SYMBOLS_WITH_OPTIMIZED_POSITIONING.has(sourceSymbolType) && !SYMBOLS_WITH_OPTIMIZED_POSITIONING.has(targetSymbolType)) {\n    // if symbols don't have optimized positioning implementations fallback to input coords\n    return {\n      sourceCoords: sourceCoords,\n      targetCoords: targetCoords\n    };\n  }\n\n  var x1 = sourceCoords.x,\n      y1 = sourceCoords.y;\n  var x2 = targetCoords.x,\n      y2 = targetCoords.y;\n  var directionVector = normalize({\n    x: x2 - x1,\n    y: y2 - y1\n  });\n\n  switch (sourceSymbolType) {\n    case _graph2[\"default\"].SYMBOLS.CIRCLE:\n      {\n        var sourceNodeSize = (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.size) || config.node.size; // because this is a circle and A = pi * r^2\n        // we multiply by 0.95, because if we don't the link is not melting properly\n\n        sourceNodeSize = Math.sqrt(sourceNodeSize / Math.PI) * 0.95; // points from the sourceCoords, we move them not to begin in the circle but outside\n\n        x1 += sourceNodeSize * directionVector.x;\n        y1 += sourceNodeSize * directionVector.y;\n        break;\n      }\n  }\n\n  switch (targetSymbolType) {\n    case _graph2[\"default\"].SYMBOLS.CIRCLE:\n      {\n        var _config$link, _config$link2; // it's fine `markerWidth` or `markerHeight` we just want to fallback to a number\n        // to avoid NaN on `Math.min(undefined, undefined) > NaN\n\n\n        var strokeSize = strokeWidth * Math.min(((_config$link = config.link) === null || _config$link === void 0 ? void 0 : _config$link.markerWidth) || 0, ((_config$link2 = config.link) === null || _config$link2 === void 0 ? void 0 : _config$link2.markerHeight) || 0);\n        var targetNodeSize = (targetNode === null || targetNode === void 0 ? void 0 : targetNode.size) || config.node.size; // because this is a circle and A = pi * r^2\n        // we multiply by 0.95, because if we don't the link is not melting properly\n\n        targetNodeSize = Math.sqrt(targetNodeSize / Math.PI) * 0.95; // points from the targetCoords, we move the by the size of the radius of the circle + the size of the arrow\n\n        x2 -= (targetNodeSize + (config.directed ? strokeSize : 0)) * directionVector.x;\n        y2 -= (targetNodeSize + (config.directed ? strokeSize : 0)) * directionVector.y;\n        break;\n      }\n  }\n\n  return {\n    sourceCoords: {\n      x: x1,\n      y: y1\n    },\n    targetCoords: {\n      x: x2,\n      y: y2\n    }\n  };\n}","map":{"version":3,"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONT/gptversion/CASEFRONT/node_modules/react-d3-graph/lib/components/graph/graph.helper.js"],"names":["Object","defineProperty","exports","value","checkForGraphConfigChanges","checkForGraphElementsChanges","getCenterAndZoomTransformation","getId","initializeGraphState","updateNodeHighlightedValue","getNormalizedNodeCoordinates","initializeNodes","_d3Force","require","_d3Selection","_d3Zoom","_graph2","_interopRequireDefault","_graph3","_err","_utils","_collapse","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","NODE_PROPS_WHITELIST","LINK_PROPS_WHITELIST","_createForceSimulation","width","height","gravity","frx","forceX","strength","FORCE_X","fry","forceY","FORCE_Y","forceStrength","forceSimulation","force","forceManyBody","_initializeLinks","graphLinks","config","reduce","links","l","collapsible","isHidden","directed","graphNodes","nodes","n","node","highlighted","prototype","hasOwnProperty","call","x","fx","y","fy","id","toString","_mergeDataLinkWithD3Link","link","index","d3Links","undefined","state","tmp","find","d3Link","pick","customProps","antiPick","toggledDirected","refinedD3Link","_tagOrphanNodes","linksMatrix","acc","nodeId","_computeNodeDegree","computeNodeDegree","inDegree","outDegree","taggedNode","_orphan","_validateGraphData","data","logWarning","INSUFFICIENT_DATA","INSUFFICIENT_LINKS","_loop","throwErr","concat","INVALID_LINKS","INVALID_LINK_VALUE","NODE_PROPERTIES_DISCARD_TO_COMPARE","_pickId","o","_pickSourceAndTarget","nextProps","currentState","nextNodes","map","nextLinks","stateD3Nodes","d3Nodes","stateD3Links","graphElementsUpdated","isDeepEqual","newGraphElements","newConfig","configUpdated","isEmptyObject","d3ConfigUpdated","d3","d3Node","containerElId","focusZoom","selector","select","zoom","transform","zoomIdentity","translate","scale","sot","_ref","graph","merge","_graph","formatedId","replace","simulation","minZoom","maxZoom","highlightedNode","draggedNode","updatedNodes","highlightDegree","linkId","updatedNode","normalize","vector","norm","Math","sqrt","pow","SYMBOLS_WITH_OPTIMIZED_POSITIONING","Set","SYMBOLS","CIRCLE","_ref2","strokeWidth","_config$node","_config$node2","_config$node3","sourceId","targetId","_ref2$sourceCoords","sourceCoords","_ref2$targetCoords","targetCoords","sourceNode","targetNode","viewGenerator","sourceSymbolType","symbolType","targetSymbolType","has","x1","y1","x2","y2","directionVector","sourceNodeSize","size","PI","_config$link","_config$link2","strokeSize","min","markerWidth","markerHeight","targetNodeSize"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkForGraphConfigChanges = checkForGraphConfigChanges;\nexports.checkForGraphElementsChanges = checkForGraphElementsChanges;\nexports.getCenterAndZoomTransformation = getCenterAndZoomTransformation;\nexports.getId = getId;\nexports.initializeGraphState = initializeGraphState;\nexports.updateNodeHighlightedValue = updateNodeHighlightedValue;\nexports.getNormalizedNodeCoordinates = getNormalizedNodeCoordinates;\nexports.initializeNodes = initializeNodes;\n\nvar _d3Force = require(\"d3-force\");\n\nvar _d3Selection = require(\"d3-selection\");\n\nvar _d3Zoom = require(\"d3-zoom\");\n\nvar _graph2 = _interopRequireDefault(require(\"./graph.const\"));\n\nvar _graph3 = _interopRequireDefault(require(\"./graph.config\"));\n\nvar _err = _interopRequireDefault(require(\"../../err\"));\n\nvar _utils = require(\"../../utils\");\n\nvar _collapse = require(\"./collapse.helper\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar NODE_PROPS_WHITELIST = [\"id\", \"highlighted\", \"x\", \"y\", \"index\", \"vy\", \"vx\"];\nvar LINK_PROPS_WHITELIST = [\"index\", \"source\", \"target\", \"isHidden\"];\n/**\n * Create d3 forceSimulation to be applied on the graph.<br/>\n * {@link https://github.com/d3/d3-force#forceSimulation|d3-force#forceSimulation}<br/>\n * {@link https://github.com/d3/d3-force#simulation_force|d3-force#simulation_force}<br/>\n * Wtf is a force? {@link https://github.com/d3/d3-force#forces| here}\n * @param  {number} width - the width of the container area of the graph.\n * @param  {number} height - the height of the container area of the graph.\n * @param  {number} gravity - the force strength applied to the graph.\n * @returns {Object} returns the simulation instance to be consumed.\n * @memberof Graph/helper\n */\n\nfunction _createForceSimulation(width, height, gravity) {\n  var frx = (0, _d3Force.forceX)(width / 2).strength(_graph2[\"default\"].FORCE_X);\n  var fry = (0, _d3Force.forceY)(height / 2).strength(_graph2[\"default\"].FORCE_Y);\n  var forceStrength = gravity;\n  return (0, _d3Force.forceSimulation)().force(\"charge\", (0, _d3Force.forceManyBody)().strength(forceStrength)).force(\"x\", frx).force(\"y\", fry);\n}\n/**\n * Receives a matrix of the graph with the links source and target as concrete node instances and it transforms it\n * in a lightweight matrix containing only links with source and target being strings representative of some node id\n * and the respective link value (if non existent will default to 1).\n * @param  {Array.<Link>} graphLinks - an array of all graph links.\n * @param  {Object} config - the graph config.\n * @returns {Object.<string, Object>} an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @memberof Graph/helper\n */\n\n\nfunction _initializeLinks(graphLinks, config) {\n  return graphLinks.reduce(function (links, l) {\n    var source = getId(l.source);\n    var target = getId(l.target);\n\n    if (!links[source]) {\n      links[source] = {};\n    }\n\n    if (!links[target]) {\n      links[target] = {};\n    }\n\n    var value = config.collapsible && l.isHidden ? 0 : l.value || 1;\n    links[source][target] = value;\n\n    if (!config.directed) {\n      links[target][source] = value;\n    }\n\n    return links;\n  }, {});\n}\n/**\n * Method that initialize graph nodes provided by rd3g consumer and adds additional default mandatory properties\n * that are optional for the user. Also it generates an index mapping, this maps nodes ids the their index in the array\n * of nodes. This is needed because d3 callbacks such as node click and link click return the index of the node.\n * @param  {Array.<Node>} graphNodes - the array of nodes provided by the rd3g consumer.\n * @returns {Object.<string, Object>} returns the nodes ready to be used within rd3g with additional properties such as x, y\n * and highlighted values.\n * @memberof Graph/helper\n */\n\n\nfunction initializeNodes(graphNodes) {\n  var nodes = {};\n  var n = graphNodes.length;\n\n  for (var i = 0; i < n; i++) {\n    var node = graphNodes[i];\n    node.highlighted = false; // if an fx (forced x) is given, we want to use that\n\n    if (Object.prototype.hasOwnProperty.call(node, \"fx\")) {\n      node.x = node.fx;\n    } else if (!Object.prototype.hasOwnProperty.call(node, \"x\")) {\n      node.x = 0;\n    } // if an fy (forced y) is given, we want to use that\n\n\n    if (Object.prototype.hasOwnProperty.call(node, \"fy\")) {\n      node.y = node.fy;\n    } else if (!Object.prototype.hasOwnProperty.call(node, \"y\")) {\n      node.y = 0;\n    }\n\n    nodes[node.id.toString()] = node;\n  }\n\n  return nodes;\n}\n/**\n * Maps an input link (with format `{ source: 'sourceId', target: 'targetId' }`) to a d3Link\n * (with format `{ source: { id: 'sourceId' }, target: { id: 'targetId' } }`). If d3Link with\n * given index exists already that same d3Link is returned.\n * @param {Object} link - input link.\n * @param {number} index - index of the input link.\n * @param {Array.<Object>} d3Links - all d3Links.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a d3Link.\n * @memberof Graph/helper\n */\n\n\nfunction _mergeDataLinkWithD3Link(link, index) {\n  var d3Links = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var config = arguments.length > 3 ? arguments[3] : undefined;\n  var state = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  // find the matching link if it exists\n  var tmp = d3Links.find(function (l) {\n    return l.source.id === link.source && l.target.id === link.target;\n  });\n  var d3Link = tmp && (0, _utils.pick)(tmp, LINK_PROPS_WHITELIST);\n  var customProps = (0, _utils.antiPick)(link, [\"source\", \"target\"]);\n\n  if (d3Link) {\n    var toggledDirected = state.config && Object.prototype.hasOwnProperty.call(state.config, \"directed\") && config.directed !== state.config.directed;\n\n    var refinedD3Link = _objectSpread({\n      index: index\n    }, d3Link, {}, customProps); // every time we toggle directed config all links should be visible again\n\n\n    if (toggledDirected) {\n      return _objectSpread({}, refinedD3Link, {\n        isHidden: false\n      });\n    } // every time we disable collapsible (collapsible is false) all links should be visible again\n\n\n    return config.collapsible ? refinedD3Link : _objectSpread({}, refinedD3Link, {\n      isHidden: false\n    });\n  }\n\n  var highlighted = false;\n  var source = {\n    id: link.source,\n    highlighted: highlighted\n  };\n  var target = {\n    id: link.target,\n    highlighted: highlighted\n  };\n  return _objectSpread({\n    index: index,\n    source: source,\n    target: target\n  }, customProps);\n}\n/**\n * Tags orphan nodes with a `_orphan` flag.\n * @param {Object.<string, Object>} nodes - nodes mapped by their id.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, Object>} same input nodes structure with tagged orphans nodes where applicable.\n * @memberof Graph/helper\n */\n\n\nfunction _tagOrphanNodes(nodes, linksMatrix) {\n  return Object.keys(nodes).reduce(function (acc, nodeId) {\n    var _computeNodeDegree = (0, _collapse.computeNodeDegree)(nodeId, linksMatrix),\n        inDegree = _computeNodeDegree.inDegree,\n        outDegree = _computeNodeDegree.outDegree;\n\n    var node = nodes[nodeId];\n    var taggedNode = inDegree === 0 && outDegree === 0 ? _objectSpread({}, node, {\n      _orphan: true\n    }) : node;\n    acc[nodeId] = taggedNode;\n    return acc;\n  }, {});\n}\n/**\n * Some integrity validations on links and nodes structure. If some validation fails the function will\n * throw an error.\n * @param  {Object} data - Same as {@link #initializeGraphState|data in initializeGraphState}.\n * @throws can throw the following error or warning msg:\n * INSUFFICIENT_DATA - msg if no nodes are provided\n * INVALID_LINKS - if links point to nonexistent nodes\n * INSUFFICIENT_LINKS - if no links are provided (not even empty Array)\n * @returns {undefined}\n * @memberof Graph/helper\n */\n\n\nfunction _validateGraphData(data) {\n  if (!data.nodes || !data.nodes.length) {\n    (0, _utils.logWarning)(\"Graph\", _err[\"default\"].INSUFFICIENT_DATA);\n    data.nodes = [];\n  }\n\n  if (!data.links) {\n    (0, _utils.logWarning)(\"Graph\", _err[\"default\"].INSUFFICIENT_LINKS);\n    data.links = [];\n  }\n\n  var n = data.links.length;\n\n  var _loop = function _loop(i) {\n    var l = data.links[i];\n\n    if (!data.nodes.find(function (n) {\n      return n.id === l.source;\n    })) {\n      (0, _utils.throwErr)(\"Graph\", \"\".concat(_err[\"default\"].INVALID_LINKS, \" - \\\"\").concat(l.source, \"\\\" is not a valid source node id\"));\n    }\n\n    if (!data.nodes.find(function (n) {\n      return n.id === l.target;\n    })) {\n      (0, _utils.throwErr)(\"Graph\", \"\".concat(_err[\"default\"].INVALID_LINKS, \" - \\\"\").concat(l.target, \"\\\" is not a valid target node id\"));\n    }\n\n    if (l && l.value !== undefined && typeof l.value !== \"number\") {\n      (0, _utils.throwErr)(\"Graph\", \"\".concat(_err[\"default\"].INVALID_LINK_VALUE, \" - found in link with source \\\"\").concat(l.source, \"\\\" and target \\\"\").concat(l.target, \"\\\"\"));\n    }\n  };\n\n  for (var i = 0; i < n; i++) {\n    _loop(i);\n  }\n} // list of properties that are of no interest when it comes to nodes and links comparison\n\n\nvar NODE_PROPERTIES_DISCARD_TO_COMPARE = [\"x\", \"y\", \"vx\", \"vy\", \"index\"];\n/**\n * Picks the id.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with id property only.\n * @memberof Graph/helper\n */\n\nfunction _pickId(o) {\n  return (0, _utils.pick)(o, [\"id\"]);\n}\n/**\n * Picks source and target.\n * @param {Object} o object to pick from.\n * @returns {Object} new object with source and target only.\n * @memberof Graph/helper\n */\n\n\nfunction _pickSourceAndTarget(o) {\n  return (0, _utils.pick)(o, [\"source\", \"target\"]);\n}\n/**\n * This function checks for graph elements (nodes and links) changes, in two different\n * levels of significance, updated elements (whether some property has changed in some\n * node or link) and new elements (whether some new elements or added/removed from the graph).\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - newGraphElements - flag that indicates whether new graph elements were added.\n * - graphElementsUpdated - flag that indicates whether some graph elements have\n * updated (some property that is not in NODE_PROPERTIES_DISCARD_TO_COMPARE was added to\n * some node or link or was updated).\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphElementsChanges(nextProps, currentState) {\n  var nextNodes = nextProps.data.nodes.map(function (n) {\n    return (0, _utils.antiPick)(n, NODE_PROPERTIES_DISCARD_TO_COMPARE);\n  });\n  var nextLinks = nextProps.data.links;\n  var stateD3Nodes = currentState.d3Nodes.map(function (n) {\n    return (0, _utils.antiPick)(n, NODE_PROPERTIES_DISCARD_TO_COMPARE);\n  });\n  var stateD3Links = currentState.d3Links.map(function (l) {\n    return {\n      source: getId(l.source),\n      target: getId(l.target)\n    };\n  });\n  var graphElementsUpdated = !((0, _utils.isDeepEqual)(nextNodes, stateD3Nodes) && (0, _utils.isDeepEqual)(nextLinks, stateD3Links));\n  var newGraphElements = nextNodes.length !== stateD3Nodes.length || nextLinks.length !== stateD3Links.length || !(0, _utils.isDeepEqual)(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) || !(0, _utils.isDeepEqual)(nextLinks.map(_pickSourceAndTarget), stateD3Links.map(_pickSourceAndTarget));\n  return {\n    graphElementsUpdated: graphElementsUpdated,\n    newGraphElements: newGraphElements\n  };\n}\n/**\n * Logic to check for changes in graph config.\n * @param {Object} nextProps - nextProps that graph will receive.\n * @param {Object} currentState - the current state of the graph.\n * @returns {Object.<string, boolean>} returns object containing update check flags:\n * - configUpdated - global flag that indicates if any property was updated.\n * - d3ConfigUpdated - specific flag that indicates changes in d3 configurations.\n * @memberof Graph/helper\n */\n\n\nfunction checkForGraphConfigChanges(nextProps, currentState) {\n  var newConfig = nextProps.config || {};\n  var configUpdated = newConfig && !(0, _utils.isEmptyObject)(newConfig) && !(0, _utils.isDeepEqual)(newConfig, currentState.config);\n  var d3ConfigUpdated = newConfig && newConfig.d3 && !(0, _utils.isDeepEqual)(newConfig.d3, currentState.config.d3);\n  return {\n    configUpdated: configUpdated,\n    d3ConfigUpdated: d3ConfigUpdated\n  };\n}\n/**\n * Returns the transformation to apply in order to center the graph on the\n * selected node.\n * @param {Object} d3Node - node to focus the graph view on.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {string} containerElId - ID of container element\n * @returns {string|undefined} transform rule to apply.\n * @memberof Graph/helper\n */\n\n\nfunction getCenterAndZoomTransformation(d3Node, config, containerElId) {\n  if (!d3Node) {\n    return;\n  }\n\n  var width = config.width,\n      height = config.height,\n      focusZoom = config.focusZoom;\n  var selector = (0, _d3Selection.select)(\"#\".concat(containerElId)); // in order to initialize the new position\n\n  selector.call((0, _d3Zoom.zoom)().transform, _d3Zoom.zoomIdentity.translate(width / 2, height / 2).scale(focusZoom).translate(-d3Node.x, -d3Node.y));\n  return \"\\n    translate(\".concat(width / 2, \", \").concat(height / 2, \")\\n    scale(\").concat(focusZoom, \")\\n    translate(\").concat(-d3Node.x, \", \").concat(-d3Node.y, \")\\n  \");\n}\n/**\n * This function extracts an id from a link.\n * **Why this function?**\n * According to [d3-force](https://github.com/d3/d3-force#link_links)\n * d3 links might be initialized with \"source\" and \"target\"\n * properties as numbers or strings, but after initialization they\n * are converted to an object. This small utility functions ensures\n * that weather in initialization or further into the lifetime of the graph\n * we always get the id.\n * @param {Object|string|number} sot source or target\n * of the link to extract id.\n * we want to extract an id.\n * @returns {string|number} the id of the link.\n * @memberof Graph/helper\n */\n\n\nfunction getId(sot) {\n  return sot.id !== undefined && sot.id !== null ? sot.id : sot;\n}\n/**\n * Encapsulates common procedures to initialize graph.\n * @param {Object} props - Graph component props, object that holds data, id and config.\n * @param {Object} props.data - Data object holds links (array of **Link**) and nodes (array of **Node**).\n * @param {string} props.id - the graph id.\n * @param {Object} props.config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {Object} state - Graph component current state (same format as returned object on this function).\n * @returns {Object} a fully (re)initialized graph state object.\n * @memberof Graph/helper\n */\n\n\nfunction initializeGraphState(_ref, state) {\n  var data = _ref.data,\n      id = _ref.id,\n      config = _ref.config;\n\n  _validateGraphData(data);\n\n  var graph;\n\n  if (state && state.nodes) {\n    graph = {\n      nodes: data.nodes.map(function (n) {\n        return state.nodes[n.id] ? _objectSpread({}, n, {}, (0, _utils.pick)(state.nodes[n.id], NODE_PROPS_WHITELIST)) : _objectSpread({}, n);\n      }),\n      links: data.links.map(function (l, index) {\n        return _mergeDataLinkWithD3Link(l, index, state && state.d3Links, config, state);\n      })\n    };\n  } else {\n    graph = {\n      nodes: data.nodes.map(function (n) {\n        return _objectSpread({}, n);\n      }),\n      links: data.links.map(function (l) {\n        return _objectSpread({}, l);\n      })\n    };\n  }\n\n  var newConfig = _objectSpread({}, (0, _utils.merge)(_graph3[\"default\"], config || {})),\n      links = _initializeLinks(graph.links, newConfig),\n      // matrix of graph connections\n  nodes = _tagOrphanNodes(initializeNodes(graph.nodes), links);\n\n  var _graph = graph,\n      d3Nodes = _graph.nodes,\n      d3Links = _graph.links;\n  var formatedId = id.replace(/ /g, \"_\");\n\n  var simulation = _createForceSimulation(newConfig.width, newConfig.height, newConfig.d3 && newConfig.d3.gravity);\n\n  var minZoom = newConfig.minZoom,\n      maxZoom = newConfig.maxZoom,\n      focusZoom = newConfig.focusZoom;\n\n  if (focusZoom > maxZoom) {\n    newConfig.focusZoom = maxZoom;\n  } else if (focusZoom < minZoom) {\n    newConfig.focusZoom = minZoom;\n  }\n\n  return {\n    id: formatedId,\n    config: newConfig,\n    links: links,\n    d3Links: d3Links,\n    nodes: nodes,\n    d3Nodes: d3Nodes,\n    highlightedNode: \"\",\n    simulation: simulation,\n    newGraphElements: false,\n    configUpdated: false,\n    transform: 1,\n    draggedNode: null\n  };\n}\n/**\n * This function updates the highlighted value for a given node and also updates highlight props.\n * @param {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, Object>} links - an object containing a matrix of connections of the graph.\n * @param {Object} config - an object containing rd3g consumer defined configurations {@link #config config} for the graph.\n * @param {string} id - identifier of node to update.\n * @param {string} value - new highlight value for given node.\n * @returns {Object} returns an object containing the updated nodes\n * and the id of the highlighted node.\n * @memberof Graph/helper\n */\n\n\nfunction updateNodeHighlightedValue(nodes, links, config, id) {\n  var value = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var highlightedNode = value ? id : \"\";\n\n  var node = _objectSpread({}, nodes[id], {\n    highlighted: value\n  });\n\n  var updatedNodes = _objectSpread({}, nodes, _defineProperty({}, id, node)); // when highlightDegree is 0 we want only to highlight selected node\n\n\n  if (links[id] && config.highlightDegree !== 0) {\n    updatedNodes = Object.keys(links[id]).reduce(function (acc, linkId) {\n      var updatedNode = _objectSpread({}, updatedNodes[linkId], {\n        highlighted: value\n      });\n\n      acc[linkId] = updatedNode;\n      return acc;\n    }, updatedNodes);\n  }\n\n  return {\n    nodes: updatedNodes,\n    highlightedNode: highlightedNode\n  };\n}\n/**\n * Computes the normalized vector from a vector.\n * @param {Object} vector a 2D vector with x and y components\n * @param {number} vector.x x coordinate\n * @param {number} vector.y y coordinate\n * @returns {Object} normalized vector\n * @memberof Graph/helper\n */\n\n\nfunction normalize(vector) {\n  var norm = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));\n  return norm === 0 ? vector : {\n    x: vector.x / norm,\n    y: vector.y / norm\n  };\n}\n\nvar SYMBOLS_WITH_OPTIMIZED_POSITIONING = new Set([_graph2[\"default\"].SYMBOLS.CIRCLE]);\n/**\n * Computes new node coordinates to make arrowheads point at nodes.\n * Arrow configuration is only available for circles.\n * @param {Object} info - the couple of nodes we need to compute new coordinates\n * @param {string} info.sourceId - node source id\n * @param {string} info.targetId - node target id\n * @param {Object} info.sourceCoords - node source coordinates\n * @param {Object} info.targetCoords - node target coordinates\n * @param {Object.<string, Object>} nodes - same as {@link #graphrenderer|nodes in renderGraph}.\n * @param {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {number} strokeWidth width of the link stroke\n * @returns {Object} new nodes coordinates\n * @memberof Graph/helper\n */\n\nfunction getNormalizedNodeCoordinates(_ref2, nodes, config, strokeWidth) {\n  var _config$node, _config$node2, _config$node3;\n\n  var sourceId = _ref2.sourceId,\n      targetId = _ref2.targetId,\n      _ref2$sourceCoords = _ref2.sourceCoords,\n      sourceCoords = _ref2$sourceCoords === void 0 ? {} : _ref2$sourceCoords,\n      _ref2$targetCoords = _ref2.targetCoords,\n      targetCoords = _ref2$targetCoords === void 0 ? {} : _ref2$targetCoords;\n  var sourceNode = nodes === null || nodes === void 0 ? void 0 : nodes[sourceId];\n  var targetNode = nodes === null || nodes === void 0 ? void 0 : nodes[targetId];\n\n  if (!sourceNode || !targetNode) {\n    return {\n      sourceCoords: sourceCoords,\n      targetCoords: targetCoords\n    };\n  }\n\n  if (((_config$node = config.node) === null || _config$node === void 0 ? void 0 : _config$node.viewGenerator) || (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.viewGenerator) || (targetNode === null || targetNode === void 0 ? void 0 : targetNode.viewGenerator)) {\n    return {\n      sourceCoords: sourceCoords,\n      targetCoords: targetCoords\n    };\n  }\n\n  var sourceSymbolType = sourceNode.symbolType || ((_config$node2 = config.node) === null || _config$node2 === void 0 ? void 0 : _config$node2.symbolType);\n  var targetSymbolType = targetNode.symbolType || ((_config$node3 = config.node) === null || _config$node3 === void 0 ? void 0 : _config$node3.symbolType);\n\n  if (!SYMBOLS_WITH_OPTIMIZED_POSITIONING.has(sourceSymbolType) && !SYMBOLS_WITH_OPTIMIZED_POSITIONING.has(targetSymbolType)) {\n    // if symbols don't have optimized positioning implementations fallback to input coords\n    return {\n      sourceCoords: sourceCoords,\n      targetCoords: targetCoords\n    };\n  }\n\n  var x1 = sourceCoords.x,\n      y1 = sourceCoords.y;\n  var x2 = targetCoords.x,\n      y2 = targetCoords.y;\n  var directionVector = normalize({\n    x: x2 - x1,\n    y: y2 - y1\n  });\n\n  switch (sourceSymbolType) {\n    case _graph2[\"default\"].SYMBOLS.CIRCLE:\n      {\n        var sourceNodeSize = (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.size) || config.node.size; // because this is a circle and A = pi * r^2\n        // we multiply by 0.95, because if we don't the link is not melting properly\n\n        sourceNodeSize = Math.sqrt(sourceNodeSize / Math.PI) * 0.95; // points from the sourceCoords, we move them not to begin in the circle but outside\n\n        x1 += sourceNodeSize * directionVector.x;\n        y1 += sourceNodeSize * directionVector.y;\n        break;\n      }\n  }\n\n  switch (targetSymbolType) {\n    case _graph2[\"default\"].SYMBOLS.CIRCLE:\n      {\n        var _config$link, _config$link2;\n\n        // it's fine `markerWidth` or `markerHeight` we just want to fallback to a number\n        // to avoid NaN on `Math.min(undefined, undefined) > NaN\n        var strokeSize = strokeWidth * Math.min(((_config$link = config.link) === null || _config$link === void 0 ? void 0 : _config$link.markerWidth) || 0, ((_config$link2 = config.link) === null || _config$link2 === void 0 ? void 0 : _config$link2.markerHeight) || 0);\n        var targetNodeSize = (targetNode === null || targetNode === void 0 ? void 0 : targetNode.size) || config.node.size; // because this is a circle and A = pi * r^2\n        // we multiply by 0.95, because if we don't the link is not melting properly\n\n        targetNodeSize = Math.sqrt(targetNodeSize / Math.PI) * 0.95; // points from the targetCoords, we move the by the size of the radius of the circle + the size of the arrow\n\n        x2 -= (targetNodeSize + (config.directed ? strokeSize : 0)) * directionVector.x;\n        y2 -= (targetNodeSize + (config.directed ? strokeSize : 0)) * directionVector.y;\n        break;\n      }\n  }\n\n  return {\n    sourceCoords: {\n      x: x1,\n      y: y1\n    },\n    targetCoords: {\n      x: x2,\n      y: y2\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}