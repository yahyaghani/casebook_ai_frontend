{"ast":null,"code":"'use strict';\n\nvar trim = require('trim');\n\nvar repeat = require('repeat-string');\n\nvar decimal = require('is-decimal');\n\nvar getIndent = require('../util/get-indentation');\n\nvar removeIndent = require('../util/remove-indentation');\n\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\nvar asterisk = '*';\nvar underscore = '_';\nvar plusSign = '+';\nvar dash = '-';\nvar dot = '.';\nvar space = ' ';\nvar lineFeed = '\\n';\nvar tab = '\\t';\nvar rightParenthesis = ')';\nvar lowercaseX = 'x';\nvar tabSize = 4;\nvar looseListItemExpression = /\\n\\n(?!\\s*$)/;\nvar taskItemExpression = /^\\[([ X\\tx])][ \\t]/;\nvar bulletExpression = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar pedanticBulletExpression = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar initialIndentExpression = /^( {1,4}|\\t)?/gm;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var previousEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var spread = false;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== tab && character !== space) {\n      break;\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character === asterisk || character === plusSign || character === dash) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || !(character === dot || commonmark && character === rightParenthesis)) {\n      return;\n    }\n    /* Slightly abusing `silent` mode, whose goal is to make interrupting\n     * paragraphs work.\n     * Well, that’s exactly what we want to do here: don’t interrupt:\n     * 2. here, because the “list” doesn’t start with `1`. */\n\n\n    if (silent && queue !== '1') {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== space && character !== tab && (pedantic || character !== lineFeed && character !== '')) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(lineFeed, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === tab) {\n        size += tabSize - size % tabSize;\n      } else if (character === space) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (character === asterisk || character === plusSign || character === dash) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && (character === dot || commonmark && character === rightParenthesis)) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === tab) {\n          size += tabSize - size % tabSize;\n          index++;\n        } else if (character === space) {\n          end = index + tabSize;\n\n          while (index < end) {\n            if (value.charAt(index) !== space) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === space) {\n            index -= tabSize - 1;\n            size -= tabSize - 1;\n          }\n        } else if (character !== lineFeed && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === space) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > tabSize;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (currentMarker === asterisk || currentMarker === underscore || currentMarker === dash) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    previousEmpty = empty;\n    empty = !prefixed && !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        spread = true;\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (previousEmpty && !commonmark) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (previousEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(lineFeed)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    spread: spread,\n    children: []\n  });\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(lineFeed);\n    now = eat.now();\n    eat(item)(listItem(self, item, now), node);\n    item = items[index].trail.join(lineFeed);\n\n    if (index !== length - 1) {\n      item += lineFeed;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(taskItemExpression);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === lowercaseX;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    spread: looseListItemExpression.test(value),\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n} // Create a list-item using overly simple mechanics.\n\n\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line; // Remove the list-item’s bullet.\n\n  value = value.replace(pedanticBulletExpression, replacer); // The initial line was also matched by the below, so we reset the `line`.\n\n  line = position.line;\n  return value.replace(initialIndentExpression, replacer); // A simple replacer which removed all matches, and adds their length to\n  // `offset`.\n\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n    return '';\n  }\n} // Create a list-item using sane mechanics.\n\n\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length; // Remove the list-item’s bullet.\n\n  value = value.replace(bulletExpression, replacer);\n  lines = value.split(lineFeed);\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(lineFeed); // We replaced the initial bullet with something else above, which was used\n  // to trick `removeIndentation` into removing some more characters when\n  // possible.  However, that could result in the initial line to be stripped\n  // more than it should be.\n\n  trimmedLines[0] = rest;\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(lineFeed);\n  /* eslint-disable-next-line max-params */\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4; // Make sure that the first nine numbered list items can indent with an\n    // extra space.  That is, when the bullet did not receive an extra final\n    // space.\n\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = space + $2;\n    }\n\n    max = $1 + repeat(space, $2.length) + $3;\n    return max + rest;\n  }\n}","map":{"version":3,"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONTt/node_modules/remark-parse/lib/tokenize/list.js"],"names":["trim","require","repeat","decimal","getIndent","removeIndent","interrupt","module","exports","list","asterisk","underscore","plusSign","dash","dot","space","lineFeed","tab","rightParenthesis","lowercaseX","tabSize","looseListItemExpression","taskItemExpression","bulletExpression","pedanticBulletExpression","initialIndentExpression","eat","value","silent","self","commonmark","options","pedantic","tokenizers","blockTokenizers","interuptors","interruptList","index","length","start","size","queue","ordered","character","marker","nextIndex","startIndex","prefixed","currentMarker","content","line","previousEmpty","empty","items","allLines","emptyLines","item","enterTop","exitBlockquote","spread","node","now","end","indented","charAt","parseInt","indexOf","indent","slice","thematicBreak","call","concat","push","trail","join","reset","type","children","enterList","enterBlock","listItem","ctx","position","offsets","offset","fn","pedanticListItem","normalListItem","checked","task","apply","arguments","gfm","match","toLowerCase","test","tokenizeBlock","replace","replacer","$0","max","bullet","rest","lines","trimmedLines","split","$1","$2","$3","$4","Number"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIG,SAAS,GAAGH,OAAO,CAAC,yBAAD,CAAvB;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,4BAAD,CAA1B;;AACA,IAAIK,SAAS,GAAGL,OAAO,CAAC,mBAAD,CAAvB;;AAEAM,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AAEA,IAAIC,QAAQ,GAAG,GAAf;AACA,IAAIC,UAAU,GAAG,GAAjB;AACA,IAAIC,QAAQ,GAAG,GAAf;AACA,IAAIC,IAAI,GAAG,GAAX;AACA,IAAIC,GAAG,GAAG,GAAV;AACA,IAAIC,KAAK,GAAG,GAAZ;AACA,IAAIC,QAAQ,GAAG,IAAf;AACA,IAAIC,GAAG,GAAG,IAAV;AACA,IAAIC,gBAAgB,GAAG,GAAvB;AACA,IAAIC,UAAU,GAAG,GAAjB;AAEA,IAAIC,OAAO,GAAG,CAAd;AACA,IAAIC,uBAAuB,GAAG,cAA9B;AACA,IAAIC,kBAAkB,GAAG,oBAAzB;AACA,IAAIC,gBAAgB,GAAG,6DAAvB;AACA,IAAIC,wBAAwB,GAAG,kCAA/B;AACA,IAAIC,uBAAuB,GAAG,iBAA9B;;AAEA,SAAShB,IAAT,CAAciB,GAAd,EAAmBC,KAAnB,EAA0BC,MAA1B,EAAkC;AAChC,MAAIC,IAAI,GAAG,IAAX;AACA,MAAIC,UAAU,GAAGD,IAAI,CAACE,OAAL,CAAaD,UAA9B;AACA,MAAIE,QAAQ,GAAGH,IAAI,CAACE,OAAL,CAAaC,QAA5B;AACA,MAAIC,UAAU,GAAGJ,IAAI,CAACK,eAAtB;AACA,MAAIC,WAAW,GAAGN,IAAI,CAACO,aAAvB;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,MAAM,GAAGX,KAAK,CAACW,MAAnB;AACA,MAAIC,KAAK,GAAG,IAAZ;AACA,MAAIC,IAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,OAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,aAAJ;AACA,MAAIC,OAAJ;AACA,MAAIC,IAAJ;AACA,MAAIC,aAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,IAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,cAAJ;AACA,MAAIC,MAAM,GAAG,KAAb;AACA,MAAIC,IAAJ;AACA,MAAIC,GAAJ;AACA,MAAIC,GAAJ;AACA,MAAIC,QAAJ;;AAEA,SAAO1B,KAAK,GAAGC,MAAf,EAAuB;AACrBK,IAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;;AAEA,QAAIM,SAAS,KAAK1B,GAAd,IAAqB0B,SAAS,KAAK5B,KAAvC,EAA8C;AAC5C;AACD;;AAEDsB,IAAAA,KAAK;AACN;;AAEDM,EAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;;AAEA,MAAIM,SAAS,KAAKjC,QAAd,IAA0BiC,SAAS,KAAK/B,QAAxC,IAAoD+B,SAAS,KAAK9B,IAAtE,EAA4E;AAC1E+B,IAAAA,MAAM,GAAGD,SAAT;AACAD,IAAAA,OAAO,GAAG,KAAV;AACD,GAHD,MAGO;AACLA,IAAAA,OAAO,GAAG,IAAV;AACAD,IAAAA,KAAK,GAAG,EAAR;;AAEA,WAAOJ,KAAK,GAAGC,MAAf,EAAuB;AACrBK,MAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;;AAEA,UAAI,CAAClC,OAAO,CAACwC,SAAD,CAAZ,EAAyB;AACvB;AACD;;AAEDF,MAAAA,KAAK,IAAIE,SAAT;AACAN,MAAAA,KAAK;AACN;;AAEDM,IAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;;AAEA,QACE,CAACI,KAAD,IACA,EAAEE,SAAS,KAAK7B,GAAd,IAAsBgB,UAAU,IAAIa,SAAS,KAAKzB,gBAApD,CAFF,EAGE;AACA;AACD;AAED;;;;;;AAIA,QAAIU,MAAM,IAAIa,KAAK,KAAK,GAAxB,EAA6B;AAC3B;AACD;;AAEDF,IAAAA,KAAK,GAAG0B,QAAQ,CAACxB,KAAD,EAAQ,EAAR,CAAhB;AACAG,IAAAA,MAAM,GAAGD,SAAT;AACD;;AAEDA,EAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa,EAAE3B,KAAf,CAAZ;;AAEA,MACEM,SAAS,KAAK5B,KAAd,IACA4B,SAAS,KAAK1B,GADd,KAECe,QAAQ,IAAKW,SAAS,KAAK3B,QAAd,IAA0B2B,SAAS,KAAK,EAFtD,CADF,EAIE;AACA;AACD;;AAED,MAAIf,MAAJ,EAAY;AACV,WAAO,IAAP;AACD;;AAEDS,EAAAA,KAAK,GAAG,CAAR;AACAgB,EAAAA,KAAK,GAAG,EAAR;AACAC,EAAAA,QAAQ,GAAG,EAAX;AACAC,EAAAA,UAAU,GAAG,EAAb;;AAEA,SAAOlB,KAAK,GAAGC,MAAf,EAAuB;AACrBO,IAAAA,SAAS,GAAGlB,KAAK,CAACuC,OAAN,CAAclD,QAAd,EAAwBqB,KAAxB,CAAZ;AACAS,IAAAA,UAAU,GAAGT,KAAb;AACAU,IAAAA,QAAQ,GAAG,KAAX;AACAgB,IAAAA,QAAQ,GAAG,KAAX;;AAEA,QAAIlB,SAAS,KAAK,CAAC,CAAnB,EAAsB;AACpBA,MAAAA,SAAS,GAAGP,MAAZ;AACD;;AAEDE,IAAAA,IAAI,GAAG,CAAP;;AAEA,WAAOH,KAAK,GAAGC,MAAf,EAAuB;AACrBK,MAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;;AAEA,UAAIM,SAAS,KAAK1B,GAAlB,EAAuB;AACrBuB,QAAAA,IAAI,IAAIpB,OAAO,GAAIoB,IAAI,GAAGpB,OAA1B;AACD,OAFD,MAEO,IAAIuB,SAAS,KAAK5B,KAAlB,EAAyB;AAC9ByB,QAAAA,IAAI;AACL,OAFM,MAEA;AACL;AACD;;AAEDH,MAAAA,KAAK;AACN;;AAED,QAAImB,IAAI,IAAIhB,IAAI,IAAIgB,IAAI,CAACW,MAAzB,EAAiC;AAC/BJ,MAAAA,QAAQ,GAAG,IAAX;AACD;;AAEDpB,IAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;AACAW,IAAAA,aAAa,GAAG,IAAhB;;AAEA,QAAI,CAACe,QAAL,EAAe;AACb,UACEpB,SAAS,KAAKjC,QAAd,IACAiC,SAAS,KAAK/B,QADd,IAEA+B,SAAS,KAAK9B,IAHhB,EAIE;AACAmC,QAAAA,aAAa,GAAGL,SAAhB;AACAN,QAAAA,KAAK;AACLG,QAAAA,IAAI;AACL,OARD,MAQO;AACLC,QAAAA,KAAK,GAAG,EAAR;;AAEA,eAAOJ,KAAK,GAAGC,MAAf,EAAuB;AACrBK,UAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;;AAEA,cAAI,CAAClC,OAAO,CAACwC,SAAD,CAAZ,EAAyB;AACvB;AACD;;AAEDF,UAAAA,KAAK,IAAIE,SAAT;AACAN,UAAAA,KAAK;AACN;;AAEDM,QAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;AACAA,QAAAA,KAAK;;AAEL,YACEI,KAAK,KACJE,SAAS,KAAK7B,GAAd,IAAsBgB,UAAU,IAAIa,SAAS,KAAKzB,gBAD9C,CADP,EAGE;AACA8B,UAAAA,aAAa,GAAGL,SAAhB;AACAH,UAAAA,IAAI,IAAIC,KAAK,CAACH,MAAN,GAAe,CAAvB;AACD;AACF;;AAED,UAAIU,aAAJ,EAAmB;AACjBL,QAAAA,SAAS,GAAGhB,KAAK,CAACqC,MAAN,CAAa3B,KAAb,CAAZ;;AAEA,YAAIM,SAAS,KAAK1B,GAAlB,EAAuB;AACrBuB,UAAAA,IAAI,IAAIpB,OAAO,GAAIoB,IAAI,GAAGpB,OAA1B;AACAiB,UAAAA,KAAK;AACN,SAHD,MAGO,IAAIM,SAAS,KAAK5B,KAAlB,EAAyB;AAC9B+C,UAAAA,GAAG,GAAGzB,KAAK,GAAGjB,OAAd;;AAEA,iBAAOiB,KAAK,GAAGyB,GAAf,EAAoB;AAClB,gBAAInC,KAAK,CAACqC,MAAN,CAAa3B,KAAb,MAAwBtB,KAA5B,EAAmC;AACjC;AACD;;AAEDsB,YAAAA,KAAK;AACLG,YAAAA,IAAI;AACL;;AAED,cAAIH,KAAK,KAAKyB,GAAV,IAAiBnC,KAAK,CAACqC,MAAN,CAAa3B,KAAb,MAAwBtB,KAA7C,EAAoD;AAClDsB,YAAAA,KAAK,IAAIjB,OAAO,GAAG,CAAnB;AACAoB,YAAAA,IAAI,IAAIpB,OAAO,GAAG,CAAlB;AACD;AACF,SAhBM,MAgBA,IAAIuB,SAAS,KAAK3B,QAAd,IAA0B2B,SAAS,KAAK,EAA5C,EAAgD;AACrDK,UAAAA,aAAa,GAAG,IAAhB;AACD;AACF;AACF;;AAED,QAAIA,aAAJ,EAAmB;AACjB,UAAI,CAAChB,QAAD,IAAaY,MAAM,KAAKI,aAA5B,EAA2C;AACzC;AACD;;AAEDD,MAAAA,QAAQ,GAAG,IAAX;AACD,KAND,MAMO;AACL,UAAI,CAACjB,UAAD,IAAe,CAACiC,QAAhB,IAA4BpC,KAAK,CAACqC,MAAN,CAAalB,UAAb,MAA6B/B,KAA7D,EAAoE;AAClEgD,QAAAA,QAAQ,GAAG,IAAX;AACD,OAFD,MAEO,IAAIjC,UAAU,IAAI0B,IAAlB,EAAwB;AAC7BO,QAAAA,QAAQ,GAAGvB,IAAI,IAAIgB,IAAI,CAACW,MAAb,IAAuB3B,IAAI,GAAGpB,OAAzC;AACD;;AAED2B,MAAAA,QAAQ,GAAG,KAAX;AACAV,MAAAA,KAAK,GAAGS,UAAR;AACD;;AAEDI,IAAAA,IAAI,GAAGvB,KAAK,CAACyC,KAAN,CAAYtB,UAAZ,EAAwBD,SAAxB,CAAP;AACAI,IAAAA,OAAO,GAAGH,UAAU,KAAKT,KAAf,GAAuBa,IAAvB,GAA8BvB,KAAK,CAACyC,KAAN,CAAY/B,KAAZ,EAAmBQ,SAAnB,CAAxC;;AAEA,QACEG,aAAa,KAAKtC,QAAlB,IACAsC,aAAa,KAAKrC,UADlB,IAEAqC,aAAa,KAAKnC,IAHpB,EAIE;AACA,UAAIoB,UAAU,CAACoC,aAAX,CAAyBC,IAAzB,CAA8BzC,IAA9B,EAAoCH,GAApC,EAAyCwB,IAAzC,EAA+C,IAA/C,CAAJ,EAA0D;AACxD;AACD;AACF;;AAEDC,IAAAA,aAAa,GAAGC,KAAhB;AACAA,IAAAA,KAAK,GAAG,CAACL,QAAD,IAAa,CAAC/C,IAAI,CAACiD,OAAD,CAAJ,CAAcX,MAApC;;AAEA,QAAIyB,QAAQ,IAAIP,IAAhB,EAAsB;AACpBA,MAAAA,IAAI,CAAC7B,KAAL,GAAa6B,IAAI,CAAC7B,KAAL,CAAW4C,MAAX,CAAkBhB,UAAlB,EAA8BL,IAA9B,CAAb;AACAI,MAAAA,QAAQ,GAAGA,QAAQ,CAACiB,MAAT,CAAgBhB,UAAhB,EAA4BL,IAA5B,CAAX;AACAK,MAAAA,UAAU,GAAG,EAAb;AACD,KAJD,MAIO,IAAIR,QAAJ,EAAc;AACnB,UAAIQ,UAAU,CAACjB,MAAX,KAAsB,CAA1B,EAA6B;AAC3BqB,QAAAA,MAAM,GAAG,IAAT;AACAH,QAAAA,IAAI,CAAC7B,KAAL,CAAW6C,IAAX,CAAgB,EAAhB;AACAhB,QAAAA,IAAI,CAACiB,KAAL,GAAalB,UAAU,CAACgB,MAAX,EAAb;AACD;;AAEDf,MAAAA,IAAI,GAAG;AACL7B,QAAAA,KAAK,EAAE,CAACuB,IAAD,CADF;AAELiB,QAAAA,MAAM,EAAE3B,IAFH;AAGLiC,QAAAA,KAAK,EAAE;AAHF,OAAP;AAMApB,MAAAA,KAAK,CAACmB,IAAN,CAAWhB,IAAX;AACAF,MAAAA,QAAQ,GAAGA,QAAQ,CAACiB,MAAT,CAAgBhB,UAAhB,EAA4BL,IAA5B,CAAX;AACAK,MAAAA,UAAU,GAAG,EAAb;AACD,KAhBM,MAgBA,IAAIH,KAAJ,EAAW;AAChB,UAAID,aAAa,IAAI,CAACrB,UAAtB,EAAkC;AAChC;AACD;;AAEDyB,MAAAA,UAAU,CAACiB,IAAX,CAAgBtB,IAAhB;AACD,KANM,MAMA;AACL,UAAIC,aAAJ,EAAmB;AACjB;AACD;;AAED,UAAI7C,SAAS,CAAC6B,WAAD,EAAcF,UAAd,EAA0BJ,IAA1B,EAAgC,CAACH,GAAD,EAAMwB,IAAN,EAAY,IAAZ,CAAhC,CAAb,EAAiE;AAC/D;AACD;;AAEDM,MAAAA,IAAI,CAAC7B,KAAL,GAAa6B,IAAI,CAAC7B,KAAL,CAAW4C,MAAX,CAAkBhB,UAAlB,EAA8BL,IAA9B,CAAb;AACAI,MAAAA,QAAQ,GAAGA,QAAQ,CAACiB,MAAT,CAAgBhB,UAAhB,EAA4BL,IAA5B,CAAX;AACAK,MAAAA,UAAU,GAAG,EAAb;AACD;;AAEDlB,IAAAA,KAAK,GAAGQ,SAAS,GAAG,CAApB;AACD;;AAEDe,EAAAA,IAAI,GAAGlC,GAAG,CAAC4B,QAAQ,CAACoB,IAAT,CAAc1D,QAAd,CAAD,CAAH,CAA6B2D,KAA7B,CAAmC;AACxCC,IAAAA,IAAI,EAAE,MADkC;AAExClC,IAAAA,OAAO,EAAEA,OAF+B;AAGxCH,IAAAA,KAAK,EAAEA,KAHiC;AAIxCoB,IAAAA,MAAM,EAAEA,MAJgC;AAKxCkB,IAAAA,QAAQ,EAAE;AAL8B,GAAnC,CAAP;AAQApB,EAAAA,QAAQ,GAAG5B,IAAI,CAACiD,SAAL,EAAX;AACApB,EAAAA,cAAc,GAAG7B,IAAI,CAACkD,UAAL,EAAjB;AACA1C,EAAAA,KAAK,GAAG,CAAC,CAAT;AACAC,EAAAA,MAAM,GAAGe,KAAK,CAACf,MAAf;;AAEA,SAAO,EAAED,KAAF,GAAUC,MAAjB,EAAyB;AACvBkB,IAAAA,IAAI,GAAGH,KAAK,CAAChB,KAAD,CAAL,CAAaV,KAAb,CAAmB+C,IAAnB,CAAwB1D,QAAxB,CAAP;AACA6C,IAAAA,GAAG,GAAGnC,GAAG,CAACmC,GAAJ,EAAN;AAEAnC,IAAAA,GAAG,CAAC8B,IAAD,CAAH,CAAUwB,QAAQ,CAACnD,IAAD,EAAO2B,IAAP,EAAaK,GAAb,CAAlB,EAAqCD,IAArC;AAEAJ,IAAAA,IAAI,GAAGH,KAAK,CAAChB,KAAD,CAAL,CAAaoC,KAAb,CAAmBC,IAAnB,CAAwB1D,QAAxB,CAAP;;AAEA,QAAIqB,KAAK,KAAKC,MAAM,GAAG,CAAvB,EAA0B;AACxBkB,MAAAA,IAAI,IAAIxC,QAAR;AACD;;AAEDU,IAAAA,GAAG,CAAC8B,IAAD,CAAH;AACD;;AAEDC,EAAAA,QAAQ;AACRC,EAAAA,cAAc;AAEd,SAAOE,IAAP;AACD;;AAED,SAASoB,QAAT,CAAkBC,GAAlB,EAAuBtD,KAAvB,EAA8BuD,QAA9B,EAAwC;AACtC,MAAIC,OAAO,GAAGF,GAAG,CAACG,MAAlB;AACA,MAAIC,EAAE,GAAGJ,GAAG,CAAClD,OAAJ,CAAYC,QAAZ,GAAuBsD,gBAAvB,GAA0CC,cAAnD;AACA,MAAIC,OAAO,GAAG,IAAd;AACA,MAAIC,IAAJ;AACA,MAAItB,MAAJ;AAEAxC,EAAAA,KAAK,GAAG0D,EAAE,CAACK,KAAH,CAAS,IAAT,EAAeC,SAAf,CAAR;;AAEA,MAAIV,GAAG,CAAClD,OAAJ,CAAY6D,GAAhB,EAAqB;AACnBH,IAAAA,IAAI,GAAG9D,KAAK,CAACkE,KAAN,CAAYvE,kBAAZ,CAAP;;AAEA,QAAImE,IAAJ,EAAU;AACRtB,MAAAA,MAAM,GAAGsB,IAAI,CAAC,CAAD,CAAJ,CAAQnD,MAAjB;AACAkD,MAAAA,OAAO,GAAGC,IAAI,CAAC,CAAD,CAAJ,CAAQK,WAAR,OAA0B3E,UAApC;AACAgE,MAAAA,OAAO,CAACD,QAAQ,CAAChC,IAAV,CAAP,IAA0BiB,MAA1B;AACAxC,MAAAA,KAAK,GAAGA,KAAK,CAACyC,KAAN,CAAYD,MAAZ,CAAR;AACD;AACF;;AAED,SAAO;AACLS,IAAAA,IAAI,EAAE,UADD;AAELjB,IAAAA,MAAM,EAAEtC,uBAAuB,CAAC0E,IAAxB,CAA6BpE,KAA7B,CAFH;AAGL6D,IAAAA,OAAO,EAAEA,OAHJ;AAILX,IAAAA,QAAQ,EAAEI,GAAG,CAACe,aAAJ,CAAkBrE,KAAlB,EAAyBuD,QAAzB;AAJL,GAAP;AAMD,C,CAED;;;AACA,SAASI,gBAAT,CAA0BL,GAA1B,EAA+BtD,KAA/B,EAAsCuD,QAAtC,EAAgD;AAC9C,MAAIC,OAAO,GAAGF,GAAG,CAACG,MAAlB;AACA,MAAIlC,IAAI,GAAGgC,QAAQ,CAAChC,IAApB,CAF8C,CAI9C;;AACAvB,EAAAA,KAAK,GAAGA,KAAK,CAACsE,OAAN,CAAczE,wBAAd,EAAwC0E,QAAxC,CAAR,CAL8C,CAO9C;;AACAhD,EAAAA,IAAI,GAAGgC,QAAQ,CAAChC,IAAhB;AAEA,SAAOvB,KAAK,CAACsE,OAAN,CAAcxE,uBAAd,EAAuCyE,QAAvC,CAAP,CAV8C,CAY9C;AACA;;AACA,WAASA,QAAT,CAAkBC,EAAlB,EAAsB;AACpBhB,IAAAA,OAAO,CAACjC,IAAD,CAAP,GAAgB,CAACiC,OAAO,CAACjC,IAAD,CAAP,IAAiB,CAAlB,IAAuBiD,EAAE,CAAC7D,MAA1C;AACAY,IAAAA,IAAI;AAEJ,WAAO,EAAP;AACD;AACF,C,CAED;;;AACA,SAASqC,cAAT,CAAwBN,GAAxB,EAA6BtD,KAA7B,EAAoCuD,QAApC,EAA8C;AAC5C,MAAIC,OAAO,GAAGF,GAAG,CAACG,MAAlB;AACA,MAAIlC,IAAI,GAAGgC,QAAQ,CAAChC,IAApB;AACA,MAAIkD,GAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,IAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,YAAJ;AACA,MAAInE,KAAJ;AACA,MAAIC,MAAJ,CAT4C,CAW5C;;AACAX,EAAAA,KAAK,GAAGA,KAAK,CAACsE,OAAN,CAAc1E,gBAAd,EAAgC2E,QAAhC,CAAR;AAEAK,EAAAA,KAAK,GAAG5E,KAAK,CAAC8E,KAAN,CAAYzF,QAAZ,CAAR;AAEAwF,EAAAA,YAAY,GAAGnG,YAAY,CAACsB,KAAD,EAAQvB,SAAS,CAACgG,GAAD,CAAT,CAAejC,MAAvB,CAAZ,CAA2CsC,KAA3C,CAAiDzF,QAAjD,CAAf,CAhB4C,CAkB5C;AACA;AACA;AACA;;AACAwF,EAAAA,YAAY,CAAC,CAAD,CAAZ,GAAkBF,IAAlB;AAEAnB,EAAAA,OAAO,CAACjC,IAAD,CAAP,GAAgB,CAACiC,OAAO,CAACjC,IAAD,CAAP,IAAiB,CAAlB,IAAuBmD,MAAM,CAAC/D,MAA9C;AACAY,EAAAA,IAAI;AAEJb,EAAAA,KAAK,GAAG,CAAR;AACAC,EAAAA,MAAM,GAAGiE,KAAK,CAACjE,MAAf;;AAEA,SAAO,EAAED,KAAF,GAAUC,MAAjB,EAAyB;AACvB6C,IAAAA,OAAO,CAACjC,IAAD,CAAP,GACE,CAACiC,OAAO,CAACjC,IAAD,CAAP,IAAiB,CAAlB,IAAuBqD,KAAK,CAAClE,KAAD,CAAL,CAAaC,MAApC,GAA6CkE,YAAY,CAACnE,KAAD,CAAZ,CAAoBC,MADnE;AAEAY,IAAAA,IAAI;AACL;;AAED,SAAOsD,YAAY,CAAC9B,IAAb,CAAkB1D,QAAlB,CAAP;AAEA;;AACA,WAASkF,QAAT,CAAkBC,EAAlB,EAAsBO,EAAtB,EAA0BC,EAA1B,EAA8BC,EAA9B,EAAkCC,EAAlC,EAAsC;AACpCR,IAAAA,MAAM,GAAGK,EAAE,GAAGC,EAAL,GAAUC,EAAnB;AACAN,IAAAA,IAAI,GAAGO,EAAP,CAFoC,CAIpC;AACA;AACA;;AACA,QAAIC,MAAM,CAACH,EAAD,CAAN,GAAa,EAAb,IAAmBN,MAAM,CAAC/D,MAAP,GAAgB,CAAhB,KAAsB,CAA7C,EAAgD;AAC9CqE,MAAAA,EAAE,GAAG5F,KAAK,GAAG4F,EAAb;AACD;;AAEDP,IAAAA,GAAG,GAAGM,EAAE,GAAGxG,MAAM,CAACa,KAAD,EAAQ4F,EAAE,CAACrE,MAAX,CAAX,GAAgCsE,EAAtC;AAEA,WAAOR,GAAG,GAAGE,IAAb;AACD;AACF","sourcesContent":["'use strict'\n\nvar trim = require('trim')\nvar repeat = require('repeat-string')\nvar decimal = require('is-decimal')\nvar getIndent = require('../util/get-indentation')\nvar removeIndent = require('../util/remove-indentation')\nvar interrupt = require('../util/interrupt')\n\nmodule.exports = list\n\nvar asterisk = '*'\nvar underscore = '_'\nvar plusSign = '+'\nvar dash = '-'\nvar dot = '.'\nvar space = ' '\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar rightParenthesis = ')'\nvar lowercaseX = 'x'\n\nvar tabSize = 4\nvar looseListItemExpression = /\\n\\n(?!\\s*$)/\nvar taskItemExpression = /^\\[([ X\\tx])][ \\t]/\nvar bulletExpression = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/\nvar pedanticBulletExpression = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/\nvar initialIndentExpression = /^( {1,4}|\\t)?/gm\n\nfunction list(eat, value, silent) {\n  var self = this\n  var commonmark = self.options.commonmark\n  var pedantic = self.options.pedantic\n  var tokenizers = self.blockTokenizers\n  var interuptors = self.interruptList\n  var index = 0\n  var length = value.length\n  var start = null\n  var size\n  var queue\n  var ordered\n  var character\n  var marker\n  var nextIndex\n  var startIndex\n  var prefixed\n  var currentMarker\n  var content\n  var line\n  var previousEmpty\n  var empty\n  var items\n  var allLines\n  var emptyLines\n  var item\n  var enterTop\n  var exitBlockquote\n  var spread = false\n  var node\n  var now\n  var end\n  var indented\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== tab && character !== space) {\n      break\n    }\n\n    index++\n  }\n\n  character = value.charAt(index)\n\n  if (character === asterisk || character === plusSign || character === dash) {\n    marker = character\n    ordered = false\n  } else {\n    ordered = true\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (!decimal(character)) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    character = value.charAt(index)\n\n    if (\n      !queue ||\n      !(character === dot || (commonmark && character === rightParenthesis))\n    ) {\n      return\n    }\n\n    /* Slightly abusing `silent` mode, whose goal is to make interrupting\n     * paragraphs work.\n     * Well, that’s exactly what we want to do here: don’t interrupt:\n     * 2. here, because the “list” doesn’t start with `1`. */\n    if (silent && queue !== '1') {\n      return\n    }\n\n    start = parseInt(queue, 10)\n    marker = character\n  }\n\n  character = value.charAt(++index)\n\n  if (\n    character !== space &&\n    character !== tab &&\n    (pedantic || (character !== lineFeed && character !== ''))\n  ) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  index = 0\n  items = []\n  allLines = []\n  emptyLines = []\n\n  while (index < length) {\n    nextIndex = value.indexOf(lineFeed, index)\n    startIndex = index\n    prefixed = false\n    indented = false\n\n    if (nextIndex === -1) {\n      nextIndex = length\n    }\n\n    size = 0\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character === tab) {\n        size += tabSize - (size % tabSize)\n      } else if (character === space) {\n        size++\n      } else {\n        break\n      }\n\n      index++\n    }\n\n    if (item && size >= item.indent) {\n      indented = true\n    }\n\n    character = value.charAt(index)\n    currentMarker = null\n\n    if (!indented) {\n      if (\n        character === asterisk ||\n        character === plusSign ||\n        character === dash\n      ) {\n        currentMarker = character\n        index++\n        size++\n      } else {\n        queue = ''\n\n        while (index < length) {\n          character = value.charAt(index)\n\n          if (!decimal(character)) {\n            break\n          }\n\n          queue += character\n          index++\n        }\n\n        character = value.charAt(index)\n        index++\n\n        if (\n          queue &&\n          (character === dot || (commonmark && character === rightParenthesis))\n        ) {\n          currentMarker = character\n          size += queue.length + 1\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index)\n\n        if (character === tab) {\n          size += tabSize - (size % tabSize)\n          index++\n        } else if (character === space) {\n          end = index + tabSize\n\n          while (index < end) {\n            if (value.charAt(index) !== space) {\n              break\n            }\n\n            index++\n            size++\n          }\n\n          if (index === end && value.charAt(index) === space) {\n            index -= tabSize - 1\n            size -= tabSize - 1\n          }\n        } else if (character !== lineFeed && character !== '') {\n          currentMarker = null\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break\n      }\n\n      prefixed = true\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === space) {\n        indented = true\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > tabSize\n      }\n\n      prefixed = false\n      index = startIndex\n    }\n\n    line = value.slice(startIndex, nextIndex)\n    content = startIndex === index ? line : value.slice(index, nextIndex)\n\n    if (\n      currentMarker === asterisk ||\n      currentMarker === underscore ||\n      currentMarker === dash\n    ) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break\n      }\n    }\n\n    previousEmpty = empty\n    empty = !prefixed && !trim(content).length\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line)\n      allLines = allLines.concat(emptyLines, line)\n      emptyLines = []\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        spread = true\n        item.value.push('')\n        item.trail = emptyLines.concat()\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      }\n\n      items.push(item)\n      allLines = allLines.concat(emptyLines, line)\n      emptyLines = []\n    } else if (empty) {\n      if (previousEmpty && !commonmark) {\n        break\n      }\n\n      emptyLines.push(line)\n    } else {\n      if (previousEmpty) {\n        break\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break\n      }\n\n      item.value = item.value.concat(emptyLines, line)\n      allLines = allLines.concat(emptyLines, line)\n      emptyLines = []\n    }\n\n    index = nextIndex + 1\n  }\n\n  node = eat(allLines.join(lineFeed)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    spread: spread,\n    children: []\n  })\n\n  enterTop = self.enterList()\n  exitBlockquote = self.enterBlock()\n  index = -1\n  length = items.length\n\n  while (++index < length) {\n    item = items[index].value.join(lineFeed)\n    now = eat.now()\n\n    eat(item)(listItem(self, item, now), node)\n\n    item = items[index].trail.join(lineFeed)\n\n    if (index !== length - 1) {\n      item += lineFeed\n    }\n\n    eat(item)\n  }\n\n  enterTop()\n  exitBlockquote()\n\n  return node\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem\n  var checked = null\n  var task\n  var indent\n\n  value = fn.apply(null, arguments)\n\n  if (ctx.options.gfm) {\n    task = value.match(taskItemExpression)\n\n    if (task) {\n      indent = task[0].length\n      checked = task[1].toLowerCase() === lowercaseX\n      offsets[position.line] += indent\n      value = value.slice(indent)\n    }\n  }\n\n  return {\n    type: 'listItem',\n    spread: looseListItemExpression.test(value),\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  }\n}\n\n// Create a list-item using overly simple mechanics.\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset\n  var line = position.line\n\n  // Remove the list-item’s bullet.\n  value = value.replace(pedanticBulletExpression, replacer)\n\n  // The initial line was also matched by the below, so we reset the `line`.\n  line = position.line\n\n  return value.replace(initialIndentExpression, replacer)\n\n  // A simple replacer which removed all matches, and adds their length to\n  // `offset`.\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length\n    line++\n\n    return ''\n  }\n}\n\n// Create a list-item using sane mechanics.\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset\n  var line = position.line\n  var max\n  var bullet\n  var rest\n  var lines\n  var trimmedLines\n  var index\n  var length\n\n  // Remove the list-item’s bullet.\n  value = value.replace(bulletExpression, replacer)\n\n  lines = value.split(lineFeed)\n\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(lineFeed)\n\n  // We replaced the initial bullet with something else above, which was used\n  // to trick `removeIndentation` into removing some more characters when\n  // possible.  However, that could result in the initial line to be stripped\n  // more than it should be.\n  trimmedLines[0] = rest\n\n  offsets[line] = (offsets[line] || 0) + bullet.length\n  line++\n\n  index = 0\n  length = lines.length\n\n  while (++index < length) {\n    offsets[line] =\n      (offsets[line] || 0) + lines[index].length - trimmedLines[index].length\n    line++\n  }\n\n  return trimmedLines.join(lineFeed)\n\n  /* eslint-disable-next-line max-params */\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3\n    rest = $4\n\n    // Make sure that the first nine numbered list items can indent with an\n    // extra space.  That is, when the bullet did not receive an extra final\n    // space.\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = space + $2\n    }\n\n    max = $1 + repeat(space, $2.length) + $3\n\n    return max + rest\n  }\n}\n"]},"metadata":{},"sourceType":"script"}