{"ast":null,"code":"'use strict';\n\nvar locate = require('../locate/code-inline');\n\nmodule.exports = inlineCode;\ninlineCode.locator = locate;\nvar lineFeed = 10; //  '\\n'\n\nvar space = 32; // ' '\n\nvar graveAccent = 96; //  '`'\n\nfunction inlineCode(eat, value, silent) {\n  var length = value.length;\n  var index = 0;\n  var openingFenceEnd;\n  var closingFenceStart;\n  var closingFenceEnd;\n  var code;\n  var next;\n  var found;\n\n  while (index < length) {\n    if (value.charCodeAt(index) !== graveAccent) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (index === 0 || index === length) {\n    return;\n  }\n\n  openingFenceEnd = index;\n  next = value.charCodeAt(index);\n\n  while (index < length) {\n    code = next;\n    next = value.charCodeAt(index + 1);\n\n    if (code === graveAccent) {\n      if (closingFenceStart === undefined) {\n        closingFenceStart = index;\n      }\n\n      closingFenceEnd = index + 1;\n\n      if (next !== graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {\n        found = true;\n        break;\n      }\n    } else if (closingFenceStart !== undefined) {\n      closingFenceStart = undefined;\n      closingFenceEnd = undefined;\n    }\n\n    index++;\n  }\n\n  if (!found) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  } // Remove the initial and final space (or line feed), iff they exist and there\n  // are non-space characters in the content.\n\n\n  index = openingFenceEnd;\n  length = closingFenceStart;\n  code = value.charCodeAt(index);\n  next = value.charCodeAt(length - 1);\n  found = false;\n\n  if (length - index > 2 && (code === space || code === lineFeed) && (next === space || next === lineFeed)) {\n    index++;\n    length--;\n\n    while (index < length) {\n      code = value.charCodeAt(index);\n\n      if (code !== space && code !== lineFeed) {\n        found = true;\n        break;\n      }\n\n      index++;\n    }\n\n    if (found === true) {\n      openingFenceEnd++;\n      closingFenceStart--;\n    }\n  }\n\n  return eat(value.slice(0, closingFenceEnd))({\n    type: 'inlineCode',\n    value: value.slice(openingFenceEnd, closingFenceStart)\n  });\n}","map":{"version":3,"sources":["/home/taymur/Documents/legal2/DATA/Highlight/newmerged/CASEFRONT/gptversion/CASEFRONT/node_modules/remark-parse/lib/tokenize/code-inline.js"],"names":["locate","require","module","exports","inlineCode","locator","lineFeed","space","graveAccent","eat","value","silent","length","index","openingFenceEnd","closingFenceStart","closingFenceEnd","code","next","found","charCodeAt","undefined","slice","type"],"mappings":"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","sourcesContent":["'use strict'\n\nvar locate = require('../locate/code-inline')\n\nmodule.exports = inlineCode\ninlineCode.locator = locate\n\nvar lineFeed = 10 //  '\\n'\nvar space = 32 // ' '\nvar graveAccent = 96 //  '`'\n\nfunction inlineCode(eat, value, silent) {\n  var length = value.length\n  var index = 0\n  var openingFenceEnd\n  var closingFenceStart\n  var closingFenceEnd\n  var code\n  var next\n  var found\n\n  while (index < length) {\n    if (value.charCodeAt(index) !== graveAccent) {\n      break\n    }\n\n    index++\n  }\n\n  if (index === 0 || index === length) {\n    return\n  }\n\n  openingFenceEnd = index\n  next = value.charCodeAt(index)\n\n  while (index < length) {\n    code = next\n    next = value.charCodeAt(index + 1)\n\n    if (code === graveAccent) {\n      if (closingFenceStart === undefined) {\n        closingFenceStart = index\n      }\n\n      closingFenceEnd = index + 1\n\n      if (\n        next !== graveAccent &&\n        closingFenceEnd - closingFenceStart === openingFenceEnd\n      ) {\n        found = true\n        break\n      }\n    } else if (closingFenceStart !== undefined) {\n      closingFenceStart = undefined\n      closingFenceEnd = undefined\n    }\n\n    index++\n  }\n\n  if (!found) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  // Remove the initial and final space (or line feed), iff they exist and there\n  // are non-space characters in the content.\n  index = openingFenceEnd\n  length = closingFenceStart\n  code = value.charCodeAt(index)\n  next = value.charCodeAt(length - 1)\n  found = false\n\n  if (\n    length - index > 2 &&\n    (code === space || code === lineFeed) &&\n    (next === space || next === lineFeed)\n  ) {\n    index++\n    length--\n\n    while (index < length) {\n      code = value.charCodeAt(index)\n\n      if (code !== space && code !== lineFeed) {\n        found = true\n        break\n      }\n\n      index++\n    }\n\n    if (found === true) {\n      openingFenceEnd++\n      closingFenceStart--\n    }\n  }\n\n  return eat(value.slice(0, closingFenceEnd))({\n    type: 'inlineCode',\n    value: value.slice(openingFenceEnd, closingFenceStart)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}